Системы контроля версий бывают двух типов - распределенные и централизованные.
Централизованная СКВ - есть сервер, на котором хранится репозиторий, изменения в котором программисты передают на сервер (все хранится в одном месте, что ненадежно).
Распределенная СКВ - у каждого разработчика есть своя копия репозитория, и они могут делиться друг с другом изменениями (чтобы в случае отказа главного сервера у каждого была \
    полная копия репозитория, и можно было бы работать дальше).

-----Основные понятия-----

Репозиторий - хранилище с кодом.
Коммит - фиксация изменений, а также конкретная версия репозитория
Бренч (ветка) - альтернативная ветка изменений, начинающаяся с конкретного коммита.
Ветка - если мы сделаем изменение не в самом последнем коммите, а в предыдущих, то появится новая ветка, ее тоже можно пушить, тогда на сервере тоже будет две ветки.

-----Основные команды-----

git init - создает репозиторий из папки на пк (сначала переходим в нее в консоли).
git clone + url репозитория в формате ссылки ssh (через htmls ссылки нужно потом вводить логин и пароль каждый push) - создание копии центрального репозитория (origin) на \
    компьютере, если после ссылки через пробел ввести другое имя, то репо созранится на пк под ним.
git add + опция + файл - добавить новый файл в репозиторий (индексирование). (либо можно применять к измененному файлу, как коммит изменений). Опция -f игнорирует gitignore. Можно \
    использовать *.txt и подобные шаблоны.
git commit -m "Comment" - фиксация изменения (без коммента не примет, маркер -a позволяет пропустить этап индексации, сразу закоммитив все отслеживаемые файлы директории \
    /применять с осторожностью/).
git push origin master - отправить коммиты на сервер в origin репозиторий, ветка master (указать свое), после чего там появится новая версия
git pull - отправить коммиты не на сервер, а в локальный репозиторий другого коммитера.
git merge - объединение ветки master с другой/другими ветками, после чего они все станут веткой master.
git mv file1 file2 - перемещение файла (авто git-add для нового и git-rm для старого файла) (также это можно считать переименованием файла).
git checkout -- file.txt - выгрузка конкретного файла из последнего коммита, опасная команда, удаляющая все изменения с прошлого коммита.
git restore file.txt - более современная версия команды выше.
git checkout branch_name - переключение веток и выгрузка их содержимого в рабочую директорию.
git rm - удаление из индекса и рабочей директории (--cached для удаления только из индекса, сами файлы сохранятся)(если просто удалить файл из директории, это будет \
    отслеживаться вне индекса, после этого можно применить git rm и коммит, чтоб файл больше не отслеживался).

При вводе команд можно использовать шаблоны (* для применения ко всем файлам), но из-за обработчика команд git нужно использовать их так - \*

Опция -n, как правило, отменяет действие команды, и только показывает, была ьы она выполнена успешно, или нет.

-----Настройка git-----

ssh-keygen -t rsa - создание ключа авторизации для работы ссылок ssh, если текущий пользователь не имеет загруженного ключа на github (содержимое созданного ключа вставляется в \
    настройках github-ssh keys при создании нового ключа)
.git/config - здесь хранится ссылка доступа к origin репо, ее можно поменять, помимо этого тут настраивается весь репозиторий, там есть три места с этими параметрами, но это самое приоритетное.
В windows git ищет файл .gitconfig в каталоге $HOME (C:\Users\$USER).
После установки git нужно указать имя и email в конфиге, так как они нужны для каждого коммита.
git config --global user.name "John Doe" (так же для почты) - параметр global применяет данные настройки далее всегда, позже можно применять другие параметры, указывая вручную.
git config --global core.editor vim - смена основного текстового редактора git
git config --list - показывает все применяемые параметры

-----Файлы и git-----

Файлы, с которыми приходится иметь дело, когда речь идёт о работе с git, можно разделить на три группы:

Непроиндексированные файлы в локальном хранилище
Проиндексированные файлы в локальном репозитории
Проиндексированные файлы на удалённом сервере

Проиндексированный файл - это файл, за которым система git умеет следить: понимает, когда у него изменилось содержимое, имя, когда он удалён и прочее.
После индексации git создает историю изменений файла даже без отправки на удаленный сервер.

-----Проверка состояния репозитория и истории коммитов-----

git status - выдает все неиндексированные файлы, индексированные без коммита, а также измененные без коммита. (-s - кратко)
git log - выдает историю коммитов текущей ветки (либо можно указать нужную ветку как параметр), имеется очень много параметров (по измененным файлам, дате, авторам веткам и т.д.).
git log --all - показать историю по всем веткам.
git log --grep="Кусок комментария коммита" - найти хэш коммита по комментарию.
git log -p (--patch) -2 - вывести историю со списком изменений в каждом коммите (в двух последних в данном случае).
git log --pretty=oneline(or short, full, fuller) - выбрать количество деталей в выводе.
git log --pretty=format:"%h - %an, %ar : %s" (%h - хэш коммита, $an - имя автора, %ar - относительная дата, %s - сообщение коммита).
git log --graph выведет схему ветвления и историю слияний (обычно используют с format or oneline для удобства отображения).
git log --since=2.weeks (или --after, эта команда работает с большим количеством форматов — можно указать определенную дату вида 2008-01-15 или же относительную дату, например \
    2 years 1 day 3 minutes ago.)
git log -S function_name - выдаст только те коммиты, в которых была добавлена или удалена указанная строка (в данном случае - вызов определенной функции).
git log -- path/to/file - показать коммиты, в которых были изменены только файлы по указанному пути (используется после всех опций).
git log --no-merges убирает коммиты слияния, в которых мало полезной информации.
git checkout b20eb8bdb8daf5fcec3ceb191c6b9b25507376ca - перейти на найденный коммит по хэшу.

Пример для вывода коммитов Джунио Хамано октября 2008 года (исключая коммиты слияния) в формате "Сокращенный хэш - содержание коммита":
git log --pretty="%h - %s" --author='Junio C Hamano' --since="2008-10-01" \
   --before="2008-11-01" --no-merges -- t/
5610e3b - Fix testcase failure when extended attributes are in use

-----Исключения отслеживания-----

Файл .gitignore находится в репозитории (если его нет, можно создать самостоятельно), и в нем прописаны все файлы, которые git игнорирует.
Запись *.txt означает игнорирование всех файло с расширением .txt
Запись !file.txt предполагает, что игнорироваться будут все файлы с расширением .txt, кроме файла file.txt

git reset HEAD file.txt - отменить добавление файла в индекс.
git restore --staged file.txt - более новый аналог команды выше.

-----Удаленный репозиторий-----

git remote - показать список настроенных удаленных репо (там будет как минимум origin, если использовалось клонирование).
-v покажет адреса для чтения и записи в репозиторий (если репо несколько, покажет все).
git remote add <shortname> <url> - добавить новый удаленный репозиторий (с помощью shortname можно не вводить весь путь).
git fetch <shortname> - получить ветки из указанного репо, после чего они будут доступны под именами <shortname>/master (или другое имя ветки). После этого можно выполнить слияние, \
    либо переключить одну из веток на локальную ветку, чтоб посмотреть содержимое.
git fetch origin скачает все новые наработки из репозитория, который был клонирован, в локальный репозиторий (без авто слияния или изменения уже сделанных наработок), \
    при необходимости можно выполнить слияние.
git pull (по умолчанию связана с веткой origin/master) - получить изменения из удаленного репо и сразу слить с текущей веткой (таким образом, все, что я добавил, \
    у меня сохранится, если не вызовет конфликта слияния, и при этом добавятся все изменения других людей).
git push <remote name> <branch-name> (например, origin master) - отправить свои коммиты (наработки) ветки <branch_name> в удаленный репозиторий <remote name> (если кто-то запушил коммиты быстрее нас, \
    нужно запуллить их и объединить со своими, иначе пуш будет отклонен).
git remote show <remote> (origin, например) - показать информацию о репо (ссылки, ветки, какие ветки есть только у меня, какие есть только на сервере, какие удалены,\
    какие ветки настроены для работы git pull и git push по-умолчанию).
git remote rename <old_name> <new_name> - переименовать удаленный репо (например, сделать не origin, а basic).
git remote remove (or rm) <remote_name> - удалить удаленный репозиторий. Это удалит все отслеживаемые ветки и настройки, связанные с этим репо.

-----git pull и push-----

git fetch + опции + репозиторий + refspec (параметр, определяющий, какие ссылки загружать и что обновлять, можно оставлять дефолт) - скачать объекты или ссылки с удаленного репозитория \
    (скачать коммиты и ветки с сервера, они появятся в локальном дереве).
git fetch -t - скачать все метки.
git fetch origin - обновить состояние всех веток в соответствии с репозиторием origin.

git pull + опции + репо и refspec - скачать и синхронизироваться (auto merge) с другим репозиторием или веткой.
--no-tags - загружать без меток
git pull origin next - выполнить слияние текущей ветки с удаленной веткой next.
Обычно слияние происходит с HEAD удаленного репозитория, однако это можно изменить.

git push + репо - обновить ссылки на удаленном репозитории вместе со связанными объектами.
git push + репо + ветка - загрузить изменения в конкретную ветку удаленного репо.

-----Тэги в git-----

git tag (-l or --list опционально при базовой команде, с условиями - обязательно) - показать все тэги в алфавитном порядке.
git tag -l "v1.8.5*" - покажет все тэги, начинающиеся на v1.8.5.
Тэги бывают легковесными (просто указывает на коммит) и аннотированными (рекомендуется, хранит дату, имя тэггера, обязательный комментарий).
git tag -a v1.4 -m "my 1.4 version" - создать аннотированный тэг с комментарием.
git tag v1.4 - создать легковесный тэг.
git show <tag_name> (v1.4) - посмотреть информацию о тэге и коммит, на который он указывает.
git tag -a v1.2 9fceb02 (хэш сумма коммита или ее часть) - добавить тэг не к текущему коммиту, а к коммиту из истории.
git push origin v1.4 - отправить свой тэг в удаленный репо.
git push origin --tags - отправить все свои тэги.
git push <remote> --follow-tags - отправить только аннотированные тэги.
git tag -d v1.4 - удалить тэг.
git push origin --delete <tagname> - удалить тэг с сервера.
git checkout v1.4 - перейти на коммит тэга. Это переводит репо в состояние detached HEAD с неприятными эффектами. Если внести изменения или сделать коммит в таком состоянии, \
    тэг не изменится, а новый коммит не будет относиться ни к одной из веток, и доступ к нему будет только по хэшу. есои надо изменить ошибки в старой версии, придется создать \
    новую ветку (git checkout -b version1.4 v1.4), она все еще будет проходить по тэгу, видимо. Если сделать коммит в этой ветке, то она сдвнется вперед и будет отличаться от \
    тэга v1.4 (то есть, как я понял, этот тэг не будет указывать на нее).
Все, кто запуллит мой репо или клонирует сервер после пуша тэгов получает и метки (не совсем понятно, есть ли тут конфликт тэгов с другими коммитерами).

-----Псевдонимы в git-----

Псевдонимы в гит это просто сокращения команд.
git config --global alias.co checkout - создание псевдонима. Теперь достаточно написать git co вместо git checkout.
git config --global alias.unstage 'reset HEAD --' - псевдоним для сокращения команды отмены индексирования. Вместо git reset HEAD -- fileA достаточно написать git unstage fileA (синтаксически логично).
git config --global alias.last 'log -1 HEAD' - популярный псевдоним для просмотра последнего коммита.
Для псевдонима для внешних команд, а не команд гита, саму команду нужно начинать с ! (!'log -1 HEAD', если показать на прошлом примере).

-----Основы ветвления в git-----

Название ветки (master, например) указвает на самый последний коммит ветки (как тэг).
HEAD указывает на текущую выбранную ветку, а не на какой-то коммит (хотя, по сути, получается, что указывает на последний коммит текущей ветки).
git log --decorate показывает, на какую ветку указывает HEAD (а также все ветки, указывающие на коммит).
git log --oneline --decorate --graph --all покажет историю коммитов, положение указателей веток и HEAD, а также схему истории ветвления.
git branch <name> - создать новую ветку (после создания вы не переключаетесь на новую ветку).
git checkout <branch name> - переключиться на другую ветку (HEAD переключится, а файлы в рабочей директории перейдут в состояние самого актуального коммита указанной ветки).
git checkout -b <newbranchname> - создать новую ветку и сразу переключиться на нее.
git branch -d <branch name> - удалить ветку (после слияния удаляем вторую).
В новой версии git появилась команда git switch, которая работает здесь так же, как и git checkout.

О слиянии:
Мы сначала переходим в ветку, в которую хотим добавить другую ветку (переходим на master), потом используем git merge <branch name>.
После этого файлы второй ветки войдут в главную, но файлы главной не войдут во вторую, это односторонняя операция.
В то же время, находясь на побочной ветке мы можем выполнить слияние с master, если нам надо что-то из новых изменений там, и продолжить работать.

Правильное использование веток:
Перед переключением веток обязательно фиксируем изменения (коммитим), чтоб не возникло проблем конфликта веток (можно также использовать stash, но коммитить проще, на первый взгляд).
Создавать ветку для каждой новой статьи/функции, после завершения выполняем слияние, удаляем ветку, в которой работали.
При необходимости багфикса переключаемся на master, создаем новую ветку, где разрабатываем исправление, после тестов выполняем слияние, удаляем ветку, в которой работали.

-----Подробнее о ветвлении-----

git branch без параметров - показать список веток (* отмечена текущая, то есть, тэг HEAD).
git branch -v - то же самое, но около каждой ветки будет показан последний коммит в ней.
git branch -vv - покажет список веток с уточнением, какая из веток отслеживается, отстает, опережает, или все сразу, относительно отслеживаемой \
    (вся информация будет актуальна на момент последнего обращения к серверу, для ее обновления git fetch --all).
git branch --merged - показать список веток, которые уже были слиты с текущей (либо с веткой, указанной в конце).
git branch --no-merged - посмотреть список неслитых веток.
git branch --move <old_name> <new_name> - локально переименовать ветку (старая ветка удаляется).
git push --set-upstream origin <new_name> - запушить переименование на сервер (на сервере появится новая ветка, но и старая будет, нужно ее удалить для полного переименования).
git push origin --delete <old_name> - удалить ветку с сервера.
Переименование master ветки очень опасное и сложное дело. После ренейма нужно: обновить все проекты, которые зависят от текущего, должны обновить код или конфиг; обновить конфиг всех тестов; \
    исправить скрипты сборки и публикации артефактов; изменить настройки репо на сервере (изменить ветку по умолчанию, обновить правила слияния и прочие настройки, зависящие от имени веток); \
    обновить документацию, исправив ссылки на старую ветку; слить или отменить запросы на слияние изменений, нацеленные на старую ветку.
Только после этого можно удалить ветку мастер с сервера (git push origin --delete master).
Процедура достаточно сложна для неопытных пользователей, лучше обойтись без этого, либо определяться с именем заранее.

Ветками можно пользовать двумя основными способами:
1. Создавать так называемые тематические ветки, где вы работете над конкретной задачей, после чего сливаете ее и удаляете.
2. Создавать ветки стабильности, где ветка master полностью стабильна, и есть несколько других веток разного уровня стабильности. Как только стабильность повышается, происходит слияние \
    с веткой со стабильностью уровнем выше.

-----Удаленные ветки-----

git clone -o <server_name> - при клонировании дать имя серверу не origin, а свое.
Ветки слежения (<remote>/<branch>) - ссылки на определенное состояние удаленных веток, которые хранят информацию об указателях веток на момент последнего взаимодействия \
    с сервером (каждое взаимодействие автоматически обновляет состояние веток слежения).
Благодаря этой функции мы можем обновиться до состояния сервера, начать редактировать ветку branch1, кто-то запушит свои обновления на сервер в эту ветку, и по адресу origin/branch1 \
    мы будем иметь доступ к этой ветке такой, какой она была на момент нашего соединения с сервером, то есть, до пуша коллеги.
git fetch origin синхронизирует мои изменения с сервером, скачивая на мой компьютер данные, которых у меня не было, и передвигая указатель origin/master \
    (расхождение с локальной веткой породит две ветки - origin/branch1 и branch1).
Если у нас есть несколько серверов, можно использовать git fetch <remote name>, после чего локально добавится еще одна ветка слежения и новая информация \
    (если ее нет ни в одной из веток слежения или в локальной ветке).
Отправить на сервер свою ветку можно через git push origin/branch1 (или свой вариант).

Интересный факт, git fetch при работе со ссылками слежения получает только указатели, но не создает новых редактируемых веток. Если они нужны, можно слить ветку слежения \
    со своей локальной веткой, либо создать новую ветку на основе ветки слежения (git checkout -b branch1 origin/branch1).
Получение новой локальной ветки таким путем автоматически свяжет эту ветку с оригинальной удаленной, поэтому git pull по умолчанию будет работать с ней.
git checkout --track origin/branch1 - сокращенная форма записи git checkout -b branch1 origin/branch1 для связи локальной ветки с удаленной.
Команда это очень распростраенная, поэтому есть еще более сокращенный вариант ее записи - при попытке перейти на ветку, которой нет локально, но есть удаленно одна ветка с таким именем, git сам \
    создаст ветку отслеживания под именем удаленной и перейдет на нее (git checkout branch1).
git branch -u origin/branch1 - настроить слежение ветки branch1 за удаленной веткой origin/branch1.
git fetch --all - обновить информацию о состоянии всех удаленных серверов.

git push origin --delete branch1 - удалить указатель ветки с сервера (возможно восстановить до срабатывания сборщика мусора).

-----Перебазирование-----

git rebase делает примерно то же, что и git merge, однако rebase может быть опасен в некоторых ситуациях.
В отличии от merge, эта команда берет историю коммитов одной ветки, потом другой, и переписывает историю, применяя их по-очереди, \
    создавая тем новый коммит (он не будет отличаться от коммита, полученного через слияние).
Эта команда делает историю коммитов чище, чем слияние, потому что в истории все операции будут выполнены линейно, даже если на самом деле это происходило прараллельно.
По сути, старые коммиты удаляются, перемещаются, и создаются новые, вместе с изменением истории.
Поэтому этой командой не стоит пользоваться, если кто-то еще использует твои ветки, потому что он может базировать на них свою работу, а потом ты их изменишь, и получится \
    путаница, которую можно частично решить командой git pull --rebase, но не всегда. Поэтому rebase хорош для локальной работы, или для команд, в которых все было оговорено заранее по этому поводу.
Как и с merge, переключаемся на ветку, используем git rebase <branch2 name>, и появится новый коммит в ветке 2, который будет иметь изменения обеих веток, после можно \
    переключиться на ветку 2 и выполнить слияние, чтоб все это стало единой веткой 2.
Если есть главная ветка, от нее идет тематическая, а от той еще одна тематическая, можно объединить мастер с 3 веткой, не объединяя со второй:
    git rebase --onto master branch2 branch3 - переключиться на ветку 3, найти изменения относительно ветки 2, и применить их к мастеру \
    (то есть, применить все то, что есть в ветке 3, но чего нет в ветке 2).
После этого маркер ветки 3 появится на один впереди маркера ветки мастер, и через merge можно выполнить перемотку (fast-forward). \
    Теперь ветки 3 как-будто никогда не было в истории, а все изменения вы выполняли сразу в мастере.
Для перебазирования без переключения веток можно использовать git rebase <basebranch> <topicbranch>.
То есть, используя git rebase master branch 2 мы перебазируем ветку мастер с изменениями второй, после выполним переход на master и merge branch2, и теперь история гласит, что всегда была только ветка master.
После этого удаляем branch2 и branch3 (они остаются после перебазирования, но уже не несут смысла, потому что все их изменения в master).

Повторяю, использовать его лучше только локально, чтоб случайно не вызвать путаницу в работе (то есть, никогда не перебазировать ветки, которые уже запушены куда-то).
До пуша можно делать что угодно, но не после, потому что тогда второй пуш сломает всем структуру.

-----Ветвление (первый конспект)-----

Коммит с тегом HEAD - самая актуальная версия (самый последний коммит) текущей ветки, при переключении веток мы переставляем тег HEAD в самый актуальный коммит ветки, а файлы в \
    рабочей директории меняются на то состояние.
Команда git checkout -b test создаст дополнительную ветку test, начало которой - последний коммит ветки мастер. (после чего можно параллельно редактировать обе ветки)
Команда git branch + имя создает новую ветку из текущей, параметр -a покажет локальные и удаленные ветки (-r только удаленные, с --list - только локальные).
Команда git checkout test переключается на указанную ветку. (-f для переключения даже с конфликтом состояний файлов)

Команда git merge test объединит ветки мастер и test, когда нам нужно будет вывести нашу разработанную функцию на основу.
После объединения веток не главную ветку мы удаляем, потому что на то место уже указывает мастер, удаление - git branch -d test.

git checkout HEAD - переход к коммиту с тегом HEAD, HEAD~4 - перейти к коммиту, предшествующему HEAD на 4 коммита.
git checkout HEAD^ - переход к прошлому коммиту (аналогично git checkout /хэш прошлого коммита/).

-----Разрешение конфликтов слияния-----

Если в ветках один файл изменен по-разному, то он будет отмечен как неслитый, и надо будет вручную его изменить (в нем будут оба варианта, можно выбрать один или объединить их по-своему), \
    после чего добавить в индекс, закоммитить и повторно слить (все неслитые файлы указаны в git status).
Простое разрешение - git checkout --ours file.txt - отклонение всех изменений ветки мастер во всех конфликтных местах и применение наших изменений.
git checkout --theirs file.txt - отклонение всех наших изменений во всех конфликтных местах.

Если нужны и те, и другие изменения, выполняем ручное слияние.
Удаляем все метки gitа в файле, оставляем одну, наиболее подходящую версию изменений (или делаем из двух одну сами).

-----Временное хранилище изменений-----

Если отредактировать файлы в индексе, то нельзя переключиться на другую ветку без коммита либо отката изменений.
Тогда можно временно сохранить текущее состояние репозитория (только измененные отслеживаемые файлы) во временное хранилище через git stash.
git stash - сохраняет текущее состояние.
git stash list - показывает список всех сохраненных состояний с индексами.
git stash apply 0 - возврат сохраненных изменений с индексом 0 с сохранением их в stash (без указания индекса команда применяется к самому новому stash).
git stash pop 0 - возврат сохраненных изменений с индексом 0 с удалением состояния из stash.
git stash drop 0 - удаление записи из stash.

-----Отмена коммитов-----

git reset может откатить состояние до прошлого коммита, но есть 3 вида этой команды.
git reset --hard HEAD~ отменяет последний коммит и удаляет все новые изменения в файлах рабочей директории (полный откат, в том числе и индекс - состояние ровно после предыдущего коммита).
git reset --mixed HEAD~ отменяет последний коммит, удаляет все новые изменения из индекса, но не файлов рабочей директории (состояние после модификации файлов, но до git add).
git reset --soft HEAD~ отменяет коммит, но не чистит индекс или изменения рабочей диркетории (состояние ровно перед командой git commit).

git commit --amend - команда, которая перезаписывает последний сделанный коммит новым коммитом из индекса. Это нужно для мелких правок, когда забыл один файл, или сделал где-то опечатку. \
    Использовать с осторожностью, поскольку предыдущий коммит удаляется полностью, даже из истории.

-----Отличия локального репо от origin-----

git diff - сравнивает содержимое вашего рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения (может применяться как к отдельному файлу, так и к репо).
git diff --staged (или --cached) сравнивает содержимое индекса с последним коммитом (показывает проиндексированные изменения).
git diff HEAD - покажет изменения в рабочей директории с последнего Нашего коммита.
git diff HEAD^ HEAD - сравнение последнего и предпоследнего моего коммита.
git diff branch - сравнение с веткой.
git diff HEAD -- ./file.txt - сравнение с текущей веткой, но показать только изменения в file.txt.

git diff test master - показать разницу веток.
git diff test...master - показать изменения в ветке master с тех пор, как была создана ветка test.

git diff --diff-filter=MRC (modification, rename, copy) - показывать только указанные изменения, но не добвление или удаление файлов.
git diff --name-status - показать только названия изменений и их вид (rename, copy), но не конкретные различия.

@@ -1,6 +1,6 @@ значит, что выводится фрагмет файла с 1 строки исходного файла, длина 6 строк (фрагмент с 1 по 6 строку).
Вторые числа - этот же фрагмент уже в измененном файле (строки с минусом там не учитываются, в старом не учитываются строки с плюсом).

Пример вывода:

@@ -1,3 +1,4 @@
+
 int main(){
   int a = 100;
   int b = 0;
@@ -20,7 +21,7 @@ int main(){
       std::cout << a;
     }
     else {
-      a -= 3;
+      a -= 2;
       std::cout << b;
     }
   }

В старом файле тут только 7 строк, так как строка с +, добавление, там отсутствовала.
В новом файле тоже 7 строк, потому что несмотря на добавление строки, одна удалена.
Начало фрагмента в новом файле не с 20, а с 21 строки из-за изменений в начале файла, которые смещают все номера на 1.