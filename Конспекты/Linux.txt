bOpen terminal:
Ctrl + Alt + T

Базовые команды:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
man + команда - справка по команде
pwd (print working directory) - показывает, в какой директории я сейчас нахожусь
ls - показывает список директорий и файлов в текущей директории (либо в указанной после команды директории)
ls --human-readable (-h) - так вводятся параметры, этот меняет представление под читаемое человеком
   -l - меняет представление на список (с указанием размеров)
   Можно указывать много сокращенных параметров после -
   -h -l = -hl
   В большинстве команд порядок произвольный, но в некоторых есть свои правила
   -la - вывод списка с указанием исполгяемсых и неисполняемых файлов

Путь бывает абсолютным (от корневой папки) и относительным (от текущей директории)
cd + директория - переход в указанную директорию
./ - текущая директория
../ - подняться на один уровень выше
~/ - домашняя директория (папка пользователя)
* - все файлы
? - один файл

mkdir + директория - создает новую директорию по указанному адресу
touch + директория и имя файла - создает новый файл
rm - удаляет файл либо директорию (-r)
cp файл1 + директория - копирование (-r копирует директорию, -rf без запросов подтверждения) (при указании на втором месте файла или директории с другим именем он будет переименован)
cp файл1 + файл2 - уопирование с заменой
mv - перемещение файлов и директорий 

Запуск встроенных/установленных программ:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Мы можем запускать программы из терминала, написав их название, после чего она запустится из терминала, и он будет недоступен
Команды, введенные после этого, будут в режиме ожидания, и если мы закроем программу "крестиком", они после этого исполнятся
Если закрыть программу командой Ctrl + c - не исполнятся
Ctrl + z ставит исполнение на паузу
После этого можно либо запустить программу fg, либо в фоне (bg). Запущенные в фоне программы не блокируют терминал.
Запуск программы с & в конце запускает ее сразу в фоне.

Запуск своих программ:
Указывается путь к программе.
Если файл исполняемый, он зеленый, если нет - белый.
chmod +x файл - делает файл исполняемым (не работает с файлами, которые невозможно исполнить, например, блокнот с "Привет")

Ввод-вывод:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Мы можем перенаправлять ввод написанием programma < файл с исходными данными для программы
Вывод перенаправляется с экрана в файл через programm > файл (если не существующий, он создастся), >> - с дозаписью в конец файла вместо замещения
Вывод ошибок - programm 2> файл, 2>> - с дозаписью в конец
Программа | программа | программа - это контейнер, здесь вывод первой программы идет как ввод второй, вывод второй как ввод 3 и так сколько угодно

Вывод содержимого файла на экран
cat файл - откроет в терминале без возможности редактирования
less файл - открывается в отдельном окне, q - выход
nano файл - открывает в терминале с возможностью редактировать (сохранение при выходе)

Скачивание файлов----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Команда wget + ссылка (скачает в текущую директорию)
-P + директория - скачает в указанную
-O + директория и имя файла + ссылка - скачает в указанную директорию и назовет указанным именем
-q - параметр убирает все сообщения программы
-r -l + "глубина" - рекурсивное скачивание на определенную глубину директорий (при указании сайта с него скачаются все файлы на определенной глубине)
-r -A + "тип" - рекурсивное скачивание файлов только определенных типов, например, jpg

Работа с архивами----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Их несколько типов, программы zip и gzip - самые популярные. unzip не удаляет архив после разархивации, а gunzip удаляет
Однако, в gzip можно указать только один файл на запаковку, (в других можно указать директории) для этого используется архиватор tar, который не сжимает файлы, а просто собирает их в пакет для gzip
Такие архивы можно разархивировать, передав в программу tar параметр -z (разархивация gzip)

tar -c - create archive
tar - x - разархивировать

tar -xvf (f всегда в конце) - разархивировать архив tar
tar -xzvf - разархивировать архив tar.gz
Есть также архиватор bzip2 (bunzip2)
tar -xjvf - разархивировать tar.bz2

Поиск----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
find директория -name "name.txt" - укажет директорию найденного файла (если не указать директорию, будет использоваться текущая)
find dir -name "*.txt" - найдет все txt файлы директории
find dir -name "image?.jpg" - найдет все jpg файлы диреткории, начинающиеся на image

Поиск по содержимому
grep "строка" файл - найдет указанную строку в указанном файле
grep -с "строка" файл - посчитает количество таких строк в файле
grep -r "строка" директория - найдет строку во всех файлах директории

Работа на сервере----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Авторизация
ssh логин@адрес -p порт (порт, если на указанном адресе находится множество компьютеров)
На сервере можно исполнять обычные команды терминала

Можно создать авторизованный ключ, чтоб проще заходить на сервер
ssh-keygen - сгенерировать ключ
ssh-add - добавить ключ в нашей системе, чтоб он использовался при подключении к серверу
~/.id_rsa.pub - публичный ключ
~/.ssh/authorised_keys - список авторизованных ключей на сервере
Копируем содержимое публичного ключа и вставляем в файл authorised_keys после входа на сервер с паролем, после чего пароль нам не потребуется

Обмен данными с сервером
scp (server copy) -P (порт) директория с файлом клиента + login@адрес:директория (либо наоборот)

Установка и удаление программ через терминал (в том числе на сервере)
sudo apt-get install программа - установка (запросит пароль)
sudo apt-get remove программа - удаление (запросит пароль)
sudo apt-get update - обновит ссылки на пакеты (если не работает install)
sudo apt-get upgrade - обновит установленные пакеты
sudo apt-get install --only-upgrade программа (обновит только указанную программу)

filezilla может графически обмениваться фалами с сервером, заходить на который нужно примерно так же, как и в терминале

Запуск приложений на сервере
Приложения на сервере запускаются так же, как и на домашнем терминале, но графические программы запускать не выйдет
У некоторых приложений есть и графическая, и консольная версия
Можно передавать параметры при запуске программы, например -h или --help, что покажет параметры программы
При этом, можно перенаправлять вывод из программ или других команд в текстовые редакторы, например так: программа | less
После выполнения программы на сервере, вывод которой предполагает графические изображения, можно их передать на клиент и открыть в просмотрщике

Контроль запускаемых программ
jobs - список запущенных программ
fg/bg (любая команда) + номер программы - обращение к конкретному процессу
В биолинукс это fg/bg (любая команда)%номер
После вывода программы из фонового режима терминал обращается к ней, поэтому можно отдавать команды типа ctrl+с

ps - показать все мои процессы
top - отслеживать все процессы в реальном времени (-u + имя пользователя для отслеживания процессов конкретного пользователя)
PID (process id) у процессов одинаков во всех трейсерах

kill + PID - завершение процесса (только активного)
kill -9 +PID - экстренное завершение процесса (при сбое работы, лучше не использовать, поскольку все смежные процессы отложатся как временные файлы)

Информация о системе:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
free -g - информация о ОЗУ
nproc - информация о количесве ядер процессора
lscpu - подробная информация о процессоре

Приостановленная программа перестает тратить ресурсы cpu, высвобождая поток, но остается в ОЗУ
Мы можем запускать программу в несколько потоков при помощи параметра -p + число потоков (в программе из примера это было так, не уверен на счет других программ)

Менеджеры терминалов и вкладки:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
В терминале, как в браузере, можно иметь несколько независимых вкладок, в которых могут исполняться программы (удобно исполльзовать вместе с top аналитикой)

Ctrl + Shift + t - создать новую вкладку
Ctrl + Shift + w - закрыть текущую вкладку (либо нажатие на крестик)
Alt + номер вкладки - переход на вкладку

Закрытие вкладки перкращает все исполняемые в ней процессы

Менеджер терминалов tmux (для серверов)
Сохраняет историю работы, гарантирует, что программа доработает до конца, даже при потере соединения с сервером
(Ctrl + B, команда) - введение команд
C - создание новой вкладки (вкладки внизу, текущая помечена *, предыдущая -)
номер вкладки - переход
N/P - следующая/предыдущая вкладка
X - закрытие вкладки (либо exit)
D - выйти, сохранив всю работу (detach)

tmux a - вернуться (attach)
tmux ls (list-sessions) - выдать список всех работающих tmux (малополезно, обычно просто в одном tmux создаются вкладки)

Ctrl + B, PgUp - переход в режим просмотра истории
В нем PgUp/PgDown/стрелки - навигация
Esc/Ctrl + C - выйти из режима

Ctrl + B, " - горизонтальное разделение вкладки на две
Ctrl + B, % - вертикальное разделение вкладки
Ctrl + B, стрелочки - перемещение по окнам вкладки
Ctrl + B, X - закрыть текущее окно

Окна работают только для той вкладки, где создавались
Окон может быть сколько угодно во все стороны

Текстовый редактор vim:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Редактор предназначен для терминала, но в нем есть графический интерфейс, так что он заменяет собой nano как более многофункциональный редактор
vim + имя файла - открыть указанный файл, либо создать новый файл с указанным именем (можно указать сразу несколько файлов)
vimtutor - автотуториал

Команды для vim
:q - выход
:help - справка
:w - сохранить изменения
:wq - сохранить и выйти
:q! - выйти без сохранения
:w + файл - сохранить изменения в файл

u - отменить действие
Ctrl+r - отменить отмену

В редакторе есть 3 режима - normal это режим командный, insert - режим ввода текста, и visual - режим выделения

Перемещение:
hjkl - аналог стрелочек (влево, вниз, вверх, вправо)
w, W - перемещение в начало word/WORD
e, E - в конец
b, B - в начало предыдущего
0 - начало строки
^ - к первому непробельному символу
$ - в конец строки
gg - в начало файла
G - в конец
:20 - перейти к строке 20
Ctrl + D, Ctrl + U - аналоги PgUp/PgDown

Удаление:
х - символ под курсором
Х - символ до курсора
de - удалить до конца текущего слова
d$ - удалить до конца строки
d5w - удалить 5 слов
dd/d10d - удалить строку/удалить строку 10

Создание:
i - перейти в режим вставки (insert) /esc выйти из него/
a - переместить курсор вправо и перейти в режим вставки
A - переместить курсор в конец строки и перейти в режим вставки
о - вставить пустую строку снизу и отредактировать ее
О = вставить пустую строку сверху и отредактировать ее

Копирование:
y + кол-во символов - скопировать
y1y - скопировать одну строку
yw - скопировать слово
yy - копировать строку

Вставка:
p - вставить перед
Р - вставить после

Поиск по документу:
/текст - искать написанное впереди курсора
?тест - искать позади
n - следующее совпадение
N - предыдущее

Поиск с заменой
:%s/искомое/на что меняю/параметры - найти указанное и заменить на указанное
параметры
g - много замен в одной строке (без него заменяется только первое совпадение в каждой строке)
с - спрашивать подтверждение каждую замену

Скрипты на bash - Основы:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
В терминале linux существует множество оболочек
Стандартная оболочка терминала - zsh
Командой sh можно перейти в оболочку sh, самую первую (выглядит очень упрощенно)
Команда bash переходит в более полноценную оболочку, где можно писать и выполнять скрипты
Оболочки в терминале открываются, как программы, и можно открывать одну в одной

Команда which + название программы указывает путь к диретории программы

Чтобы документ стал скриптом, в первой строке нужно написать
#!/директория программы, в которой следует запустить скрипт

Файл нужно сделать исполняемым через chmod +x (либо передать файл напрямую в bash командой bash + путь к программе)
Расширение у скриптов обычно .sh

Стоит помнить, что действия, вроде перехода в домашнюю директорию, не сохранятся после исполнения скрипта, потому что переход произойдет в оболочке скрипта, а не в нашей стандартной оболочке
Однако созданные файлы сохраняются для всех оболочек, так как являются часть файловой системы

Скрипты на bash - Переменные:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Имя переменной стандратное (буквы, цифры, _, не может начинаться с цифры)
Значения переменной - числа, строки (можно без кавычек, нужны только если есть пробелы), отдельные символы

Присваивание классическое - имя=значение
var=~/ - переменная хранит путь домой

Чтение:
$var или ${var} (второе для более точного обозначения, например, если после переменной указывается что-то еще)
var2=$var/Documents - var2 будет равно ~/Documents

Суть фигурных скобок:
echo "Path is $var" - вывод Path is ~/
echo "Path is ${var}2" - Path is ~/2 (без скобок читалась бы переменная var2)

Bash разделяет одинарные и двойные кавычки - одинарные трактуются как строка ($ не будет читать переменную, просто напечатается), а двойные - как контент, который может включать переменные
Однако здесь также есть экранирование, \$ в двойных кавычках отменит вызов переменной

Также стоит отметить, что строки выделены красным, функции оранжевым, объявленные переменные зеленым, а вызванные переменные - фиолетовым цветами

Аргументы:
Передаются при вызове скрипта (./script.sh arg1 arg2 arg3)
$1, $2 возвращают значение переданного аргумента внутри скрипта
$0 - возвращает имя скрипта (какой командой он был вызван, без аргументов)
$# - возвращает количество переданных аргументов

При обращении к незаданной перменной ошибки не будет, в ней хранится пустая строка

Скрипты на bash - Ветвление:--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if [[условие]]
then
# команды для истинности
fi - конец ветвления

Условие может вводиться с определенными флагами
-z + переменная или строка - переменная или строка пуста
-n + перменная или строка - не пуста
var1 == var2 - равно
var1 != var2 - не равно

Пример
if [[ -z $1 ]]
then
    echo "Первый аргумент пустой"
fi

Для чисел и строк
-eq (==) - равно
-ne (!=) - не равно
-lt (<) - меньше
-le - меньше или равно
-gt (>) - больше
-ge - больше или равно

Условия файлов
-e путь - путь существует
-f путь - это файл
-d путь - это директория
-s путь - размер файла больше нуля
-x путь - файл исполняемый

Условия логические
! - отрицание логического выражения
&& - и
|| - или

Альтернативные условия:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if [[условие]]
then
  команды для истинности
elif [[условие2]]
then
  команды для ложности 1 и истинности второго условия
else
  команды для ложности всех условий
fi

case переменная in
значение)
  команды для истинности
  ;;
значение2)
  команды для истинности
  ;;
*)
  команды для ложности всех аргументов выше
esac

Циклы:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
for переменная in список значений через пробел
do
  команды
done

break - прервать выполнение
continue - перейти на следующее значение цикла

while [[условие]]
do
  команды
done

read переменная - типо input в python, записывает ввод в переменную

Арифметика на bash:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
let "переменная + выражение"
let "c = a+b" (можно без кавычек, если без пробелов вообще)
let a=a+b let a+=b (эти команды одинаковы)
$ можно ставить перед переменными, а можно не ставить, это не ошибка

Операции +-*/
% деление по модулю
** возведение в степень

Внешние программы в bash:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
переменная=`программа`
a=`echo "text"` - в переменную запишется результат выполнения программы, то есть строка text

У всех программ есть "Код возврата" - если он равен 0, значит программа завершилась корректно, если любое другое значение - не корректно
Код возврата выдается через $?
Выйти с кодом - exit + код (0 или не ноль)

Можно проанализировать любую команду - сначала выполняем ее, потом echo $?

Пример анализа программы (квадратные скобки не ставятся)
if `программа`
then
Действия, если корректное завершение
else
Для некорректного
fi

Функции в bash:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Имя_функции () (имя как и у переменных)
{
действия
}

Вызов функции - просто написать имя, главное, чтоб после инициализации функции

Если использовать в коде функции $1, $2..., то при вызове функции надо будет передать нужное количество аргументов, как и с программами

Переменные в функции бывают глобальными и локальными (глобальные по дефолту)
Локальная переменная создается так local var=1
Локальные переменные существуют только в функции, обратится к ним извне невозможно

Компактная запись функции (в одну строку)
Имя_функции () { действие1; действие2;} (нужно просто добавить ; как знак новой строки, у послежней строки он тоже нужен)
; работает переносом строки не только с функциями, но и с чем угодно
if [[case]]; then

Продвинутый поиск + редактирование:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
find -iname "name_of_file" - поиск по имени без учета регистра
find -path "path" - поиск с учетом названий папок, в которых файл может быть
find -size размер - поиск с учетом размера
find -maxdepth число - искать на определенной глубине каталога
find -mindepth число - искать с определенной глубины каталога

grep -l "строка" файл - выдает список файлов с указанной строкой
grep -L "строка" файл - выдает список файлов, в которых строчки нет
grep -n "строка" файл - выводит номер найденных строк в файле
grep -m число "строка" файл - не искать после нахождения определенного количества резульатов
grep -A число "строка" файл - выводить дополнительно указанное количество строк после совпадения
grep -B до совпадения
grep -C до и после

grep -E "шаблон" файл - найти все строки в файле по шаблону
grep -E "^go" text.txt - найдет все строки, начинающиеся с Go
grep -E "go$" text.txt - найдет все строки, оканчивающиеся на Go
grep -E " [a-z]+right " - найдет все строки, в которых есть слова, кончающиеся на right, но имеющие перед этим хоть одну букву в указанном диапазоне (типо bright)
grep -E " [a-z]?right " - имеющие 0 или одну букву, то есть, слово right теперь тоже подходит
grep -E " [a-zA-z]*ight " - найдет все слова, кончающиеся на ight в диапазоне, предполагающем еще и большие буквы

sed 'инструкция' файл - потоковый редактор, читает строки из входа или указанного файла, выдает вывод (для вывода в файл прописываем > файл, или ставим параметр -i для перезаписи файла)
sed 's/John/Nick/g' old.txt > new.txt - заменить все John на Nick в файле old и записать в файл new (s - замена, g - global, то есть, во всем файле)
sed -r 's/J[a-z]*n/Nick/g' old.txt > new.txt - заменит все слова, начинающиеся на J и кончаются на n
sed -n '2,4p' file.txt - вывести строки файла со второй по 4 (p - print)
sed '2,4d' file.txt - выведет все строки, кроме строк 2-4 (d - delete)
sed -n '/[0-9]\{2\}/p' file.txt - вывести строки с двумя цифрами подряд
sed '2,/[Rr]ight/d' file.txt - вывести все строки кроме строк со второй по строку, содержащую слово right

Графики в gnuplot:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
plot 'file' using 1:2 - построить график по файлу, в котором первая колонка координата х, а вторая - у
plot 'file' using 1:2, 'file' using 1:3 - построить сразу два графика по файлу, где первая колонка это х, а 2 и 3 - У

set title 'text' - добавить заголовок графику
set xtitle 'text' - добавить заголовок оси Х
set ytitle 'text' - добавить заголовок оси У
plot 'file' using 1:2 title 'text' - добавить название ряду данных
set key autotitle columnhead - брать название ряда данных из первой строчки файла

set xtics число
set ytics число - установить количество отсечек на осях
set xrange [от:до]
set yrange [от:до] - установить границы значений на осях
set xtics('0' 0.0, '1/4' 0.25, '1/2' 0.5, '1' 1.0,) - задать конкретные надписи на отсечках
set logscale y - логарифмическая шкала для оси у
set autoscale xy - автомасштабирование (по умолчанию)
unset autoscale z - отключение

Потоковый режим в gnuplot:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Пример скрипта для потоковой работы программы
#! /usr/bin/gnuplot -persist
set terminal png enhanced
set output "plot.png"
команды...

gnuplot --persist имя скрипта (запуск скрипта, либо можно сделать скрипт исполняемым через chmod+x и запустить его)
Можно использовать переменные в скрипте, чтоб не менять входные данные много раз
gnuplot -e "перменная1='данные'; переменная2='данные'" plot.gnu - поменять перменные при запуске (но для этого эти переменные не должны присваиваться в скрипте)

Права доступа:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
users - узнать, кто сейчас в системе
cat /etc/passwd - просмотреть файл со всеми пользователями системы
groups имя_пользователя - узнать, в какой группе пользователь состоит

ls -l путь - узнать, кто владеет директорией или файлом и какие права у них есть (RWX - read, write, execute)
chmod  [ugoa] [+-] [rwx] путь (изменить права user, group, other, all; дать или забрать; какие именно права)
chmod 777 file.txt - восьмеричный код, открывающий все права для всех к этому файлу или директории
chown new_user:new_group путь - изменить владельца или группы файла или директории (можно по-одному)
root (группа root) - суперпользователь
sudo меняет пользователя н апользователя root, у которого есть все права
Если сделать что-то от имени root, например, создать файл, то обычный пользователь не будет исметь к нему доступа

Разные программы:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

wc - word counter
wc -l file - посчитает строки в файле
wc -w - слова
wc -c - символы

diff file1 file2 - сравнивает файлы или директрории (при больших различиях можно перенаправить вывод в редактор, написав в конце, например, | less)
-r для директорий
-q для того, чтобы сравнить и сказать, отличаются ли объекты, не указывая различия

du -h ~/ - показывает, сколько места на диске занимает файловая система с указанной точки (здесть - во всей системе) - -h это human readable
du --max-depth 1 -h покажет все лишь на глубине 1
df -h - покажет, сколько место свободно во всей системе, на всех жестких дисках

head -n 10 file - выведет первые 10 строк файла
tail -n 10 file - выведет последние 10 строк файла

Больше об известных командах:-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

mkdir ./ {dir1,dir2} - для создания сразу нескольких директорий
touch ./ {file1,file2}.txt - создаст два файла
ls --sort=size/time -l ./ - отсортировать данные по размеру или времени создания

&> || &>> both.txt - перенаправит и вывод, и вывод ошибок в один файл
2>&1 - перенаправление stderr в stdout
1>&2 - наоборот
programm 2>/dev/null - перенаправить ошибки в никуда, чтоб они нигде не сохранялись и никуда не выводились (1> для вывода)
cat /dev/null > file.txt - файл будет заполнен ничем, то есть, будет чист
