Вводный модуль---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

СУБД - система управления базами данных.

Основные понятия БД (Баз данных):
Сущность - как класс в ООП, какая-то основа, хранящаяся в базе данных, таблица. Не каждая таблица - сущность, есть таблицы, связующие сущности.
Объект - экземпляр из ООП, в данном случае, экземпляр сущности, запись в таблице.
Атрибут - свойство, характеризующее сущность, например, название столбца в таблице.
Кортеж - набор значений (объектов) конкретных атрибутов, то есть, это строка таблицы. Представлены кортежи в виде множества всех пар атрибутов и их значений для конкретного объекта.
Домен - набор допустимых значений атрибута, например для атрибута пол допустимые значения - м и ж. Также доменами являются базовые типы данных атрибутов, например атрибут количества чего-то предполагает целое число больше нуля.
Идентификатор - атрибут с уникальным для данной таблицы значением.

Архитектура СУБД.
Основные компоненты:
Ядро - оперирует процессами, взаоимдействие с памятью, сетью, файловой системой и т.д.
Диспетчер данных - механизм транзакций, взаимодействие с кэшем и проверка доступа к данным.
Диспетчер запросов - парсер запросов (проверяет валидность запросов), процедуры оптимизации запросов, исполнитель запросов.
Набор инстументов для служеюных операций - резервное копирование, восстановление, мониторинг работы других компонентов.

Характеристика реляционных СУБД.
Преимущества:
Простота схемы данных, даже без особого опыта можно построить сколь угодно сложную систему (по словам лектора).
Логическая и физическая независимость от данных - возможность изменения и удаления сузностей и атрибутов без необходимости переписывать подключенные программы.
Целостность и защищенность данных.
Методологический подход к проектированию баз данных (простота).

Недостатки:
Низкая скорость доступа к данным.
Меньшая гибкость при добавлении своих типов данных и операций (то есть, дополнение базовых средств РСУБД может быть не столь целесообразно, как использование НРСУБД).

Язык структурированных запросов SQL - это стандарт в индустрии, которому стараются соответствовать, поэтому при разработки нового диалекта стараются не выходить за рамки стандартов.

Самый распространенный диалект - Oracle database - решение для высоконагруженных систем.
MySQL - распространенный свободный диалект SQL, который используется в большинстве веб сайтов.
PostgreSQL - менее популярный диалект, по сути, это постреляционная СУБД.
MS SQL - распространен на серверах Microsoft.
SQLite - очень простая СУБД, зачастую используется для локальных приложений.
Access - альтернатива SQLite от Microsoft с рядом доп. функций.

Базовые операции SQL:
use base_name; - подключить базу данных, к которой будут идти запросы (обязательно, в начале, можно использовать несколько)

select * from table_name; - показать всю таблицу
select payer_email, sum; - показать только указанные атрибуты
select * from table_name where sum>900; - ключевое слово where позволяет добавить условия для выборки

select payer_email, sum from billing 
	where sum>900 and currency='CHF'; - можно комбинировать условия через and

select payer_email, sum from billing 
	where sum>900 and currency in ('CHF', 'GBP'); - через in можно указать список значений (можно провести аналогию с list), и так будет выбираться не одно значение валюты, а все перечисленные

select payer_email, sum from billing 
	where sum>900 and currency not in ('CHF', 'GBP'); - так можно указать список исключений

insert into table_name values(
'alex@mail.com',
'leo@mail.com',
'500.00', 'MYR',
'2010-08-20',
'comment'); - insert into table_name + список значений по порядку, столько же, сколько атрибутов - внести новый кортеж в таблицу

insert into table_name(payer_email, recipient_email, sum, currency, billing_date)
values(
'alex@mail.com',
'leo@mail.com',
'500.00', 'MYR',
'2010-08-20'); - можно указать список атрибутов после таблицы, если не нужно добавлять значение по все поля

update table_name set currency='USD'; - обновить во всей таблице значение атрибута currency на указанное
update table_name set currency='USD' where currency='MYR' limit 1; - обновить значение с условием (в safe mode нужно указывать limit, то есть, количество таких изменений для update и delete, либо отключить режим)

delete from billing where payer_email is null or payer_email = '' or recipient_email is null or recipient_email = '' - delete from table_name - удалить все кортежи, через where ставятся условия

Агрегация данных - работа с определенной группой данных, например, подсчет общей суммы значений атрибута, среднего значения и т.д.
select count(любое значение, пусть будет 1) from table_name; -  по умолчанию, посчитать количество строк в таблице, но при использовании группировки, может делать подсчеты для группы
select avg(имя атрибута для подсчета) from table_name; - подсчитать среднее арифметическое всех значений указанного атрибута
select max(имя атрибута для подсчета) from table_name; - показать максимальное значение среди всех значений указанного атрибута
select min(имя атрибута для подсчета) from table_name; - показать минимальное значение среди всех значений указанного атрибута
select datediff(att_date2, att_date1) from table_name; - выдать разницу в днях между датами атрибутов, также можно подсчитать и среднее значение для результатов

select max(date) as max_days from table_name; - присуждение псевдонима новому атрибуту данных (переменная) через as var_name для дальнейшего использования

Если добавить в select команды агрегации данных и один из атрибутов, то появится ошибка, гласящая о необходимости группировки данных по этому атрибуту.
Потому что среднее/максимальное число всего одно, а имен клиентов целая таблица, возникает конфликт. Таким образом, мы можем подсчитать среднее/максимальное число для каждого клиента.
select max(date) as max_days, client_name from table_name group by client_name; - группировка выходных данных по значению атрибута (например, по имени клиента)

Стандарт написания, признанный программой.

SELECT 
  MAX(date) as max_days, 
  client_name 
FROM table_name 
group by client_name 
order by max_days; - order by позволяет выбрать атрибут для упорядоченного вывода по возрастанию (в данном случае, по max_days), их может быть несколько.

order by max_days DESC; - сортировка по убыванию (ASC - по возрастанию, дефолт)

Реляционные базы данных------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ОТНОШЕНИЕ - ЭТО ТАБЛИЦА
РЕЛЯЦИОННЫЕ relative - основанные на отношениях, то есть, реляционные БД это БД в таблицах.

Понятие модели данных:
Четкого определения нет (почему-то), поэтому определяется по наличию стрех компонентов - структурной части (наличие объектов, построенных в виде древа), манипуляционная (операторы и команды для управления) и ограничения целостности (например, невозможность иметь больше одного родителя ребенку)
Достаточно неясное объяснение, но будем считать, что это просто свойства СУБД и БД определенного вида, для каждого вида свои свойства.

Реляционная модель данных. Структурная часть:
Все данные должны иметь свой тип, типы близки к типам данных в ЯП (имеют свое множество значений, доступные операции и набор символов для описания типа).

Типы данных реляционных БД:
Целочисленные - Int, Bigint, Smallint.
С дробной частью - Numeric/Decimal (с фиксированной точностью), Float, Double.
Строковые - char (фиксированного размера), varchar, string.
Календарные - date, time, datetime, timestamp.
Другие - xml, JSON.
Null - отсутствие значения.

Структурные элементы:
Домен - условно, это расширенный тип данных, а именно, набор всех доступных для этого атрибута значений (если в целочисленном типе данных могут быть числа определенного диапозона, то домен хранит все возможные значения, и сравнивает логически со введнными данными, при несовпадении бросается исключение).
Домен можно создать, чтоб ограничить набор возможных значений. (в начале еще одно определение)

Атрибут - свойство, характеризующее сущность, например, название столбца в таблице (представлены типом данных, зачастую varchar или числовыми).
Кортеж - набор значений (объектов) конкретных атрибутов, то есть, это строка таблицы. Представлены кортежи в виде множества всех пар атрибутов и их значений для конкретного объекта (плюс тип данных).
Схема отношения - именованное множество пар типа имя атрибута + тип данных/домен (по сути, таблица, или иная сущность, а именно, их заголовок).
Схема БД - множество именованных схем отношений. (таблиц может быть много, и они могут быть связаны)
Тело отношения - множество кортежей конкретной схемы отношения.
Значение отношения - пара множеств схема отношения + тело отношения. (соотношение заголовка таблицы с ее содержанием)
Свойства отношений - отсутствие дубликатов кортежей, а также их и атрибутов упорядоченности, ввиду того, что они - множества.

describe table_name; - посмотреть структуру таблицы

Реляционная модель данных. Манипулятивная часть:
DML - data manipulating language - язык запросов SQL.

Реляционная модель данных. Ограничения целостности:
Целостность сущности и целостность ссылок.
Целостность сущности:
Все кортежи должны быть отличимы, отличаются они по ключам, ключом могут выступать как несколько атрибутов (составной), так и один (простой), но не null. Любой ключ может быть первичным.
Видимо, ключ, это тот атрибут в кортеже, по которому можно разделить кортежи.

Ссылочная целостность:
Внешний ключ - это атрибут в одной таблице, который может выступать ключом для другой. (в примере в одной таблице был список работников и номера их отделов, а во второй был список отделов, и номера отделов ссылаются на номера в списке)
При этом обязательно для каждого указанного значения внешнего ключа должна найтись запись в подчиненной таблице, инае ссылочная целостность нарушится.
Избежать такого нарушения можно тремя способами - блокировкой невалидной операции, указанием вместо невалидного значения null, и каскадным удалением, что довольно опасно и может удалить множество данных.

Архитектура ANSI SPARC-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Архитектура определяет принцип организации СУБД, не обязательно реляционной.
Принцип данной архитектуры - разные группы пользователей имеют разное представление данных.

Простым пользователям излишне знать, какие ограниения есть в БД, как данне физически и логически хранятся, поэтому их от этой информации абстрагируют.
Администраторы БД должны иметь возможность изменять схему БД без учета особенностей физического хранения данных. То есть, они не должны знать, какие новые файлы создаются, когда они работают с моделью, что меняется в файловой системе и т.д.
Внутренняя структура БД также не должна зависеть от физических асектов хранения информации, то есть, на нее не должно влиять то, как там файловая система, в оперативной она памяти, или нет, и т.д.

Таким образом, архитектура ANSI SPARC выделяет три уровня абстракции:
Внешний уровень - пользовательское представление.
Концептуальный уровень - логическая структура БД для архитекторов БД, то есть то, с помощью чего представлена эта БД - атрибуты, отношения, кортежи и т.д.
Внутренний уровень - аспекты физической реализации, то, как БД работает изнутри, какие методы оптимизации она использует и все подобное.

Из такого разграничения рождаются два принципа:
Логическая независимость - изенения на концептуальном уровне не должны менять представления внешнего уровня.
Физическая независимость - изменения внутреннего уровня не должны влиять на концептуальный, чтобы администраторы и проектировщики могли спокойно работать, независимо от внутренних изменений БД.

Таким образом, каждая группа пользователей работает на своем уровне, и никак не влияет на другие уровни и их пользователей.

Выборки из нескольких источников---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Если select обращается к нескольким источникам данных, он возвращает результат соединения в виде нестрогого подмножества декартова (прямого) произведения результатов выборок (то есть, каждый элемент с каждым).
Если атрибуты таблиц имеют разные имена, не обязательно указывать явно название таблицы, но если таблицы имеют одинаковые атрибуты, их надо указывать явно.
Запросы соединения в select можно использовать многократно.

Для ограничения декартова произведения есть несколько операторов языка:
CROSS JOIN - дефолтное декартово произведение.
INNER JOIN - наиболее распространенный ограничитель, позволяющий получать тета соединения (соединения, записи в которых удовлетворяют некоторым специальным условиям), но обязательно условие.
Например, при условии равенства атрибута одной таблицы атрибуту другой, будут выведены обе таблицы полностью, и оба одинаковых атрибута будут продублированы. В естественном соединении они бы объединились, без необходимости вводить условие.

LEFT OUTER JOIN и RIGHT OUTER JOIN - соединения, определенным образом расширяющие внутреннее соеднинение (inner).
Если мы делаем внутреннее соединение двух таблиц купленных товаров и их id, если в списке купленных товаров будут перечислены не все id, то те не будут выведены. При внешнем соединении их тоже покажет, а недостающие поля будут заполнены null. При левом - те, что в левой таблице, при правом - что в правой.
FULL OUTER JOIN - полное внешнее соединение (и левая, и правая).
NATURAL JOIN - естественное соединение (подвид INNER).

Судя по примеру, декартово произведение уместно в очень редких случаях. Если есть таблица списка товаров и цифры их категории, а также таблица категорий для расшифровки этих цифр, то их объединение даст не расшифровку, а перемножение каждого товара на каждую категорию, что некорректно.

Пример использования несколько JOIN и нескольких условий сортировки:
USE store;

SELECT 
    good.name as good_name, category.name as category_name
FROM
    category
INNER JOIN
	category_has_good ON category.id = category_has_good.category_id
INNER JOIN
	good ON category_has_good.good_id = good.id
ORDER BY good_name, category_name;

Пример использования нескольких условий группировки и подсчета определенных единиц:
USE store;

SELECT 
    client.first_name, client.last_name, count(status.name) as new_sale_num
FROM
	client
INNER JOIN 
	sale on client.id = sale.client_id
INNER JOIN
	status on sale.status_id = status.id
WHERE status.name = 'new'
GROUP BY first_name, last_name;

Мы можем объединять несколько выборок (несколько select) двумя способами - через union и all.

union удалит все продублированные кортежи, а all выведет все кортежи обеих выборок.

select ...
union
select ...;

Пример использования объединения и FULL JOIN с условием (FULL JOIN используется без ON, поэтому мы объединяем левый и правый JOIN):
SELECT 
    good.name as good_name, category.name as category_name
FROM
    category
LEFT OUTER JOIN
	category_has_good ON category.id = category_has_good.category_id
LEFT OUTER JOIN
	good ON category_has_good.good_id = good.id
UNION
SELECT 
    good.name as good_name, category.name as category_name
FROM
    category
RIGHT OUTER JOIN
	category_has_good ON category.id = category_has_good.category_id
RIGHT OUTER JOIN
	good ON category_has_good.good_id = good.id
ORDER BY good_name, category_name;

Пример использования WHERE NOT EXISTS, с помощью которого можно находить исключения, сделав внутри select запрос, после чего будут выведены все кортежи, которые под данный запрос не подпадают. В данном случае, выбираем источники без клиентов.
Также с помощью WHERE EXISTS можно делать проверку наличия в качестве условия.

SELECT 
    source.name AS source_name
FROM
    source
WHERE NOT EXISTS( SELECT * FROM client
        WHERE client.source_id = source.id)
UNION
SELECT
	source.name AS source_name
FROM
	source
INNER JOIN
	client ON source.id = client.source_id
INNER JOIN
	sale ON client.id = sale.client_id
INNER JOIN
	status ON sale.status_id = status.id
WHERE status.name = 'rejected';

Триггеры и хранимые процедуры------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Процедурные расширения SQL(PSM) - надстройки расширения, призванные расширить функционал SQL.
Процедуры и триггеры очень зависят от конкретной СУБД, поэтому они не универсальны по своей сути.

Хранимые процедуры выполняются сервером, либо максимально близко к месту хранения данных.
Процедуры могут возвращать данные аналогично select.
Пользовательские функции - процедуры, которые могут быть использованы в запросе после объявления, классические функции.
Нативные хранимые процедуры - процедуры, уже реализованные в SQL.
Процедуры, реализуемые на языках общего назначения (Java для oracle, python для PostgreSQL, C# для MS SQL).

Преимущества хранимых процедур:
Производительность, поскольку данные обрабатываются на сервере, где и хранятся.
Организация поддержки целостности - с ростом сложности БД трудно ограничиваться одним лишь ограничением целостности.
Скрытие структуры данных за интерфейсом, чтоб программисту было проще работать с ней.
Модульность - расширяемость, повторяемость.
Безопасность - возможность за счет расширений добавить ряд проверок прав и пользователей.
Возможность использования общего кода при работы базы с несколькими приложениями.

Недостатки хранимых процедур:
Разделение бизнес-логики между приложением и БД.
Меньшая языковая выразительность процедурных расширений SQL.
Неуниверсальность (для каждой СУБД свои процедуры).
Для использования надо погружаться в особенности используемой СУБД.
Сложность отладки, особенно базовыми средствами некоммерческих СУБД (а отладка процедур на общих языках и в платных СУБД имеет проблемы).
Версионирование (контроль версий) для процедур требует, зачастую, каких-то дополнительных надстроек, в которых тоже могут быть ошибки.

Триггеры.
Триггер — это хранимая процедура, которая не вызывается непосредственно, а исполняется при наступлении определенного события (вставка, удаление, обновление строки).
Таблица, для которой специфицирован триггер, называется предметной (subject table).
Операции, которые их триггерят, могут быть отменены.

Особенности работы триггеров:
Возможность инициировать не только изменениями в таблицах, но и в схеме БД.
Может выполняться как единожды для блока кода, так и для каждой затрагиваемой строки.
Возможно использования как старых, так и новых значений (говоря об update, delete, старое значение - изначальное, новое - которое мы присуждаем в операции).
Вызов процедур, инициирование триггеров (можно инициировать триггеры в триггерах, но есть опасность переполнения стека).
Транзакционность и сохранение состояния - если в процессе инициирования триггера было брошено исключение, состояние предметной таблицы возвращается в состояние до инициации триггера.
Последовательность исполнения - мы можем на одно событие создать несколько триггеров, если они инициируются в разное время (до ввода, после и т.д.), при этом их исполнение будет последовательно, но порядок срабатывания - в порядке создания, что нелогично. Таким образом, чтоб изменить порядок, надо удалить все триггеры, и создать заново в нужном порядке.

Варианты использования:
Проверка данных на соответствие согласованности.
Поддержка согласованности вытекает из этого.
Журналирование и аудит - можно автоматически вести лог изменений с помощью триггеров.
Запуск процедур, не связанных с обработкой данных (не сказали, каких, но случаи редки, видимо).

Недостатки триггеров:
Непрозрачность - невозможно отследить выполнение триггеров, и это вредит отладке, поскольку они могут инициировать каскад операций, который никак не будет фиксироваться, тем более, триггеры могут создавать другие работники.
Сложность отладки - вытекает из того же, когда триггеры инициируют другие триггеры, отладка крайне затруднена.
Производительность - обработка триггеров замедляет сами операции.
Глобальность - триггеры не существуют для каких-то конкретных таблиц, поэтому их срабатывание не совсем гибко, и может произойти там, где не ожидается.

Пример создания триггера или процедуры:

DELIMITER // - переопределяем разделитель с точки с запятой, потому что они могут использоваться в теле процудуры/триггера, на //.
CREATE TRIGGER on_update_order
  AFTER UPDATE - до или после операции, и какой
  ON 'order' FOR EACH ROW указываем таблицу и тип (поблочно или построчно)
BEGIN
  CALL update_order_history(NEW.id, NEW.status_id, NEW.sum); - тело триггера, что выполняется после инициации, в данном случае вызывается ранее созданная процедура. Благодаря NEW можно использовать обновленные данные.
END
//

Проектирование баз данных----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Задачи проектирования:
Отображение объектов предметной области средствами модели данных (не всегда просто определить те сущностиЮ которые нужно хранить в БД).
Отображение связей этих объектов.
Достаточность представления предметной области для пользователей (пользователь должен иметь достаточный доступ к данным для работы с ними).
Формирование ограничений целостности (определить, какими ограничениями обладают данные нашей предметной области и реализовать их. Например, нужно сделать так, чтоб в поле пола нельзя было написать неподходящие слова).
Минимизация аномалий - аномалии в БД имеют место быть, и сложно говорить об их исчезновении, об этом будет больше в нормализации БД.

Реляционная модель не очень подходит для проектирования БД по ряду причин:
Плохое отображение семантики.
Трудно моделировать действительно сложные предметные области на основе отношений.
Отсутствие формальных правил для преобразования требований предметной области в схему БД.
Для сложных систем не всегда можно однозначно отделить сущности от связей.

Таким образом, были придуманы более подходящие для проектирования модели данных.

Проектирование с использованием семантических моделей:
Формирование концептуальной схемы данных.
Преобразование к логической схеме данных на основе некоторой модели данных (в реляционной модели это было определением отношений и ограничений целостности).
Преобразование к физической схемем данных (создать таблицы и заполнить их данными в терминах SQL, чтобы пользователи могли эти данные получать).

Наиболее популярная семантическая модель - модель сущность-связь (ER).
Может быть представлена в разном виде, но чаще всего имеет графическое представление в виде диаграммы сущность-связь, или ER-диаграммы.
Понятия ER-модели:
Сущность, тип сущности - сущность это объект реального мира, который может быть отличим от других (для библиотеки сущность - это конкретная книга, а ее тип - это книга в общем понимании).
Связь, тип связи. Связи бинарны, обязательно связывают два типа сущности (как два разных, так и один и тот же /рекурсивная связь/).
Атрибут, тип данных, домен. Как и для реляционной модели, но тут атрибут не всегда имеет тип данных, поскольку на концептуальном этапе сложно определить тип данных для конкретного атрибута.
Ключ - некий набор атрибутов, который уникально определяет сущность.
Ограничения целостности.

Концептуальное программирование----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Этапы концептуального программирования:
Выделение сущностей, типов сущностей.
Определить атрибуты, типы данных, домены.
Выделить связи.
Определить ключи для сущностей.
Определить ограничения целостности (для каждого атрибута вводится понятия допустимых значений /для возраста от 0 до 100/, разрешенных значений /для возраста работника от 18 до 65/, и существующих).

Выделение типов сущностей:
Это работа бизнес аналитика и проектировщика БД.
Выяснение потребностей и представления предметной области для каждой роли пользователя (от простого работника до статиста).
Выделение независимых типов сущностей (как я понял, типы, с которыми не строятся связи, но лектор говорил о самих связях как об отдельном независимом типе сущности).
Отбрасываются ненужные типы сущностей, учет которых либо сложен, либо бессмысленен.
Именование типов сущностей для различения.

Определение связей:
Наиболее сложный и творческий процесс проектирования.
Типы связей (на диаграмме БД множественное окончание связи или одиночное показывает, что это за тип связи).
Один ко многим/многие к одному с другой стороны (source и client, из одного источника могло прийти несколько клиентов, но каждый клиент пришел только из одного источника).
Многие ко многим (в реляционной модели нет специальных формализмов вроде внешнего ключа для описания таких связей, поэтому он реализуется через вспомогательную таблицу с двумя внешними ключами один ко многим для двух таблиц).
Один к одному (например, человек и id, человек и его паспорт; такие связи можно реализовать в одном отношении, а можно в разных, в зависимости от задач).
Кратность связей.
1 (для промежуточной таблицы многие ко многим со стороны многих, связь обязательно есть, но с чем-то одним), от 0 до 1 (кратность связи один ко многим со стороны одного, многие либо присоединены к одному, либо нет), от 0 до n (со стороны многих, связи может не быть, а может быть бесконечность), от 1 до n (когда связь обязана быть, но не обязательно одна).

Определение атрибутов:
Выделяются атрибуты типов сущностей.
Выделяются атрибуты связей (например, цена конкретного заказа в промежуточной таблице как атрибут связи между товарами и заказами).
Простые и составные атрибуты (простой с одним значением, а составные могут иметь несколько и быть разделенными на простые, например адрес может быть просто строкой в таблице, а может быть разделен на город, улицу и т.д. в специальных БД адресов).
Определение типов данных, доменов, если это возможно на данном этапе.
Именование атрибутов (нужно определять так, чтоб отличались от типов данных, потому что в ER модели это вещи связанные).

Выбор ключей:
Определение ключевых атрибутов.
Выбор первичного ключа (тоже может быть простым и составным).
Для слабых сущностей (таблиц), которые не имеют набора атрибутов для уникальной идентификации, вводятся синтетические ключевые атрибуты.

Проверка:
Наличие связей один к одному (разные типы сущностей, объединенные в одну таблицу, желательно избегать)..
Наличие избыточных связей (следует избегать этого по возможности).
Мысленный эксперимент - проверка выполнимости пользовательских операций для каждого типа роли.
Обсуждение с пользователями.

Особые случаи. Супертипы и подтипы.
Иногда может прослеживаться иерархия сущностей, и в таком случае вступает в ход система наследования. То есть, есть какой-то супертип, имеющий подтипы, например посетители школы это ученики и учителя.
При этом сущность любого подтипа является одновременно и сущностью супертипа. Сущность супертипа обязательно являюется сущностью некоего подтипа (не может быть кого-то, кроме учеников, учителей, и прочих подтипов).
Также не может быть сущностей нескольких подтипов сразу.

Особые случаи. Взаимоисключающие связи.
То есть, связи, которые не могут работать одновременно, либо одна, либо другая. Пример: водитель привозит машину в сервис, связь водитель-автомобиль заменяется связью мастер-автомобиль, и они не могут быть одновеременно.

Логическое и физическое проектирование---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Реализация схемы данных на основе выбранной модели данных.
Для РМД процесс перехода от концптуальной к логической может быть во многом автоматизирован.
РМД логическая модель:
Определить набор схем отношений.
Выделить первичные и внешние ключи.

Правила автоматизированного перехода:
Каждый простой (не супертип и не подтип) тип сущности отображается в отношении.
Атрибуты модели отображаются в атрибуты отношений.
Компоненты уникального идентификатора отображаются в первичный ключ отношений.
Связи один к одному и один ко многим отображаются в виде внешних ключей.
Связи многие ко многим отображаются с созданием дополнительного отношения.
Сложные связи (более, чем между двумя типами сущностей) объединяются при помощи нового типа сущности (создается промежуточное отношение, объединяющая все три и более таблицы).
Многозначные атрибуты выделяются в новый тип сущности, то есть, новое отношение (атрибуты, которые не могут быть реализованы в существующих типах сущности, и имеющих свою структуру, например, история заказов в магазине).
Далее нормализация, но это будет в новом модуле.

Особые случаи - супетипы.
Такие сложные структуры преобразуются двумя способами - либо объединением в одно отношение супертипа и всех подтипов, либо созданием отношения для каждого объекта. У каждого способа свои плюсы и минусы.

Физическое проектирование БД-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Перенос логической модели в конкретную СУБД.
Определение типов данных для атрибутов (поскольку у разных СУБД типы данных называются по-разному, надо адаптировать их).
Определение допустимости неопределенных значений (null).
Выбор стратегии обработки исключений при нарушении ссылочной целостности.
Уточнение названий таблиц, атрибутов, триггеров и прочего, при этом ключевые слова и операторы СУБД не должны пересекаться с этими именами.
Хранение и/или вычисление производных атрибутов (те, что появляются, например, при перемножении атрибутов цены и заказов) - на данном этапе можно включить некоторые производные атрибуты в схему, если их постоянное вычисление может быть неоптимальным.
Реализация ограничений целостности (в конкретной СУБД может не быть средств для реализации запланированных ограничений, тогда используются процедуры и триггеры).
Формирование описания модели данных в рамках выбранной СУБД (написание SQL скрипта, который можно было бы открыть в нашей СУБД, что привело бы к формированию нашей схемы БД).
Определение плана построения индексов (будет в 5 модуле) для оптимизации, их описание также может быть помещено в скрипт формирования физической БД.
Определение способа хранения данных в нашей конкретной БД. У каждой СУБД есть свои ограничения и свои способы хранения, нужно выбрать оптимальный для нашей предметной области. При этом, надо учитывать доступное для хранения место.
Если таблица занимает слишком много места, для обеспечения быстродействия применяется метод, при котором она может быть разбита построчно/по столбцам и разнесена по разным файлам или даже по разным узлам кластера.
Такая оптимизация называется секционированием и партицированием.

Полученная физическая БД в итоге должна соответствовать ряду критериев:
Достаточная пропускная способность.
Достаточно низкое время ответа для работы.
Достаточное количество утилизируемых ресурсов.
При недостаточности ресурсов подаются запросы на расширение.

SQL DDL (язык редактирования структуры БД SQL)-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Создание схемы в MySQL:
CREATE SCHEMA IF NOT EXISTS 'store' DEFAULT CHARACTERS SET utf8;
Под схемой в MySQL понимается сама база данных, то есть, эти понятия тождественны. Однако, в других СУБД, типо Oracle, схема это совокупность таблиц и всего прочего, а база данных - совокупность таких схем, зачастую слабо связанных между собой.

Создание домена в PostgreSQL (в MySQL не существует доменов):
CREATE DOMAIN SALE_STATUS AS VARCHAR(45)  #название, тип данных
  DEFAULT 'new'  #значение по умолчанию
  CHECK (VALUE IN ('new', 'process', 'assembly', 'ready', 'delivering', 'issued', 'rejected'))  #проверка, что значение вписывается в определенный набор значений
  CONSTRAINT SALE_STATUS_NOT_NULL CHECK (VALUE IS NOT NULL);  #запрет неопределенного значения

Синтаксис создания таблиц:
Ограничения описания столбца - запрет неопределенного значения | указать, что это первичный ключ или его часть, также можно наложить ограничение уникальности | определение ссылок | ограничение значения через CHECK
Определение ссылок - имя таблицы и колонка, на которую ссылаются | указание через MATCH SIMPLE(самое частое)/FULL/PARTIAL тип проверки значения внешнего ключа | указание действия при попытке нарушения ссылочной целостности удалением | обновлением
Действия при нарушении ссылочной целостности - одно из пяти: NO ACTION, RESTRICT, CASCADE, SET DEFAULT, SET NULL. Первые два отменяют выполнение такой операции, 3 производит каскадное изменение, изменение значения на указанное, либо на неопределенное
Ограничения, созданные самой таблицей - огранчиение первичного ключа либо уникальности | определение внешнего ключа | функция проверки какого-либо условия
При написании кода использовать апостроф вместо кавычек (буква ё)!!!

Пример создания:
CREATE TABLE IF NOT EXISTS `store`.`category` (
  `id` INT NOT NULL,  #перечисляются столбцы с типом данных и указанием возожности неопределенного значения
  `name` VARCHAR(255) NULL,
  PRIMARY KEY (`id`))  #определяем первичный ключ (простой в данном случае)
ENGINE = InnoDB  #указываем движок для хранения данных, в MySQL наиболее распространен вот этот
DEFAULT CHARACTER SET = utf8  #указание кодировки для хранения
COLLATE = utf8_general_ci;  #указываем набор правил для сравнения строк, нужно не для всех СУБД

Еще пример:
CREATE TABLE IF NOT EXISTS `best_offer_sale` (
    `id` INT NOT NULL,
    `name` VARCHAR(255) NULL,
    `dt_start` DATETIME NOT NULL,
    `dt_finish` DATETIME NOT NULL,
    PRIMARY KEY (`id`))
ENGINE = InnoDB
DEFAULT CHARACTER SET = utf8
COLLATE = utf8_general_ci;

Изменение таблиц:
Пример добавления нового столбца, удаления столбца, и удаления внешнего ключа (апострофы не обязательны).
ALTER TABLE `store`.`sale`
  ADD COLUMN `is_exclusive_case` BOOLEAN NOT NULL DEFAULT 0,
  DROP COLUMN dt_created,
  DROP FOREIGN KEY fk_order_status1;

Для удаления столбца, являющегося внешним ключом, нужно удалить внешний ключ.
Однако, при использовании оператора ALTER TABLE надо помнить, что использование проверок через CHECK не будет работать, и мы не можем ограничивать вводимые данные таким образом.

Удаление таблицы:
DROP TABLE `source`;

Пример добавления ограничения внешнего ключа:
ALTER TABLE `client`
    ADD COLUMN `source_id` INT NULL,
    ADD CONSTRAINT fk_source_id FOREIGN KEY (source_id) REFERENCES source(id);  #добавление ссылки на поле id таблицы source

Нормализация РБД-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Нормализация - создание такого набора отношений, который соответствует некоторым требованиям, с целью найти наилучшую группировку атрибутов по отношениям в данной схеме.
Таким образом мы можем избегнуть в схеме избыточность данных (дублирование и прочее) и различные аномалии.

В требованиях нормализации, как правило, используются первичный ключ/потенциальный ключ и функциональные зависимости.
При этом у каждой нормальной формы указаны свои правила функциональной зависимости по отношению к первичному ключу или потенциальному.

Нормальные формы:
ННФ - ненормализованная форма, без требований.
1НФ - первая нормальная форма, одна ячейка таблицы должна иметь только одно значение, и это обязательно для реляционной модели, так что ННФ, по сути, не реляционная.
2НФ, 3НФ, БКНФ - устранение частых аномалий.
Менее распространенные:
4НФ - решение проблем с многозначной зависимостью.
5НФ - решение проблем с зависимостями соединения.
Есть и другие, но проектирование БД, как правило, обходится первыми 4 (до БКНФ).

Функциональная зависимость описывает связь между атрибутами внутри одного отношения.
Если в отношении один атрибут функционально зависит от другого, то каждое значение первого атрибута связано только с одним значением второго, тогда как второй атрибут может быть связан с несколькими значениями первого.

Детерминант - атрибут, от которого полностью функционально зависит некоторый другой атрибут. В самом простом случае детерминант это первичный ключ.

Разбор основных нормальных форм:
Ненормализованная форма - в одной ячейки таблицы может находиться несколько различных значений какого-то атрибута.
Если же в одной ячейке таблицы может находиться только одно значение атрибута, то мы имеем дело с 1НФ.

Способы приведения ННФ к 1НФ:
Например, у нас есть таблица, 1 столбец которой - задача, а второй - исполнители, и их там несколько.
Можно либо добавить кортежи по числу исполнителей, продублировав для них задачу в 1 столбце (как раз по правилу функциональной зависимости), либо выделить задачи и исполнителей в отдельные отношения, соединив связью многие ко многим.

Полная функциональная зависимость - если независимый атрибут, от которого зависит другой, является составным, то полная функциональная зависимость это случай, когда второй зависит от всех частей составного атрибута.

Таблица для примера - ЗадачииИсполнители (многие ко многим), атрибуты:
id (первичный ключ)
id задачи (потенциальный ключ)
id исполнителя (потенциальный ключ)
название роли
можно ли делигировать роль (данный атрибут зависит от ключа транзитивно через название роли)
дата назначения задачи
дата создания задачи (не полностью зависитью зависит, так как не связан с исполнителем).

2НФ - отношение находится в 1НФ, при этом все атрибуты, не входящие в первичный ключ, полностью функционально зависят от него. Если же первичный ключ не составной, а простой, и другие атрибуты функционально от него зависят, то это отношение уже в 2НФ.
Составной первичный ключ обычно возникает при приведении к 1НФ ННФ путем связи многие ко многим (в дополнительном отношении будет составной первичный ключ).
Например, в таком отношении может быть внешний ключ для первого и второго связуемых отношений (id задачи и исполнителя по прошлому примеру), плюс общий id для этого отношения. Все это и есть составной первичный ключ, а остальные атрибуты либо полностью, либо не полностью функционально от него зависят.
Если хоть один атрибут не полностью функционально зависит от ключа, то это не 2НФ.
В то же время, если неключевых атрибутов нет, то условие 2НФ выполняется, так как все (ни одного) такие атрибуты зависят от ключа.

Приведение ко 2НФ:
Если есть атрибут, который зависит только от одного из связуемых отношений (только задачи или исполнитель), то для приведения можно переместить данный атрибут в само это отношение задачи или исполнителя.
В нашем примере атрибут дата создания задачи надо переместить в сущность задачи.

Транзитивная зависимость - если 2 атрибут зависит от 1, а 3 от 2, то 3 зависит от 1 транзитивно (опосредованно).

3НФ - отношение находится во 2НФ, при этом не должно быть транзитивных зависимостей от первичного ключа, только полная функциональная.

Приведение к 3НФ:
Выведение отдельной сущности для транзитивного атрибута (в данном случае создается таблица Роль, связанная с ЗадачииИсполнители, для чего добавляем туда новый атрибут id роли).
При этом атрибут название роли начнет зависеть от id роли, поэтому его тоже перемещаем в Роль, и в сущности Роли оба неключевых атрибута будут напрямую зависеть от ключа id роли (Роль: id роли, название роли, можно ли делигировать).
Все сущности подподают под требование 3НФ.

НФБК (нормальная форма Бойса-Кодда) - отношение в 3НФ, все детерминанты являются потенциальным ключом.

Может так получиться, что части составного ключа могут зависеть друг от друга. Для НФБК такого быть не должно, то есть, каждый детерминант (определитель, от которого зависят неключевые элементы) должен быть потенциальным ключом (то есть, может однозначно определить кортеж в таблице без другого ключа).
Если же есть непотенциальные ключи, то их надо вывести в отдельную сущность, либо убрать лишние ключи, оставив только один первичный ключ (что лучше, потому как проще работать с одним детерминантом в нормализации).
В нашем примере id задачи и id исполнителя убрать нельзя, поскольку они также являются внешними ключами. Но мы можем убрать атрибут id, который является общим id кортежа, тогда ключ будет приведен к одной паре.
Это единственная НФ из основных, которая выдвигает требования к связям между ключами, поэтому для приведения к 3НФ это делать не нужно.

Другие нормальные формы (НФ4, НФ5, ДКНФ (доменно-ключевая), НФ6):
Понятие многозначной зависимости - необходимо иметь как минимум 3 атрибута для ее возникновения, при этом и 2, и 3 зависят от 1, но не связаны друг с другом.
Например, 1 это предмет, 2 это преподаватель, а 3 - аудитория. Преподавателю неважно, в какой аудитории будет пара, и аудитории неважно, что в ней за преподаватель. Но оба они зависимы от предмета.
Такая зависимость называется нетривиальной, и таких зависимостей в 4НФ быть не должно.
Если у нас есть такая таблица, для представления всех возможных комбинаций значений пришлось бы добавлять столько кортежей с предметом, сколько есть вариантов связи 2 и 3. А если б преподаватель уволился, то все связанные с ним аудитории пропали б из таблицы. Поэтому это плохо.

Приведение к 4НФ:
Отношение в 3НФ для простого и НФБК для составного ключей.
Нужно декомпозировать таблицу на несколько, по количеству атрибутов, что зависят от 1, но не друг от друга.
Таким образом, это будут таблицы предмета и преподавателя, и предмета и аудитории.

5 и 6 нормальные формы создают слишком много новых таблиц при декомпозиции, и в итоге уже не улучшают, а ухудшают производительность, поэтому полностью нормализованная таблица - плоха.

Использование ORM------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Object Relational Mapping - объектно реляционное отображение, технология, связывающая модель базы данных с концепциями ООП, позволяет работать с данными, как с объектами.

Преимущества ORM:
Представление модели данных в ORM независимо от СУБД (то есть, такое представление универсально для всех СУБД реляционной модели).
Упрощенное моделирование базы данных (мы не привязаны к особенностям конкретной СУБД).
ORM предоставляет больше механизмов обеспечения целостности данных (есть много паттернов доменов для атрибутов, например, e-mail адреса).
Возможность использования наследования моделей.

Недостатки ORM:
Медленнее чистого SQL.
Возможные проблемы с комплексными запросами (например, многие ORM не работают с агрегацией данных, поэтому приходится писать запрос на SQL, но в приложениях редко используются такие запросы).
Идея ORM схожа, но в каждой программе своя специфика, требующая дополнительного обучения.

Django ORM:
Пример схемы из двух таблиц Категории и Продукты.

from django.db import models

class Category(models.Model):
  name = models.CharField(max_length=100)  #как и в SQL указывается имя атрибута и его тип

  def get_available_products(self):  #пример процедуры
    """Gets products of current category with quantity>0"""
    return Products.objects.filter(category=self, quantity__gte=0)

class Product(models.Model):
  name = models.CharField(max_length=100)
  price = models.DecimalField(max_digits=10, decimal_places=2)  #digits это количество целых цифр в числе, decimal - после запятой
  quantity = models.IntegerField)(default=0)
  category = models.ForeignKey(Category, null=True)  #указание внешнего ключа

Механизм миграции:
Нужен для упрощения работы с различными версиями схем нашей БД.
Позволяют быстро переключаться между ними, в том числе откатываться назад.
Мы не получаем те же кортежи, что были в той версии, но все атрибуты и отношения сохраняются.

В django миграции реализованы двумя командами:
manage.py makemigration - создает инструкции на python для отображения текущего состояния моделей (создание точки восстановления запуском этого кода в django ORM).
manage.py migrate - применить хранимый снимок (привести settings.py к виду, который сохранен в models.py).

Связь многие ко многим в django orm производится автоматически в виде:
categories = models.ManyToManyField(Category), также есть связь один к одному.
Связь один ко многим осуществляется через указание внешнего ключа в поле "многих" на "одного".
Некоторые модели уже есть в ORM, например, модель User с данными авторизации (логин и пароль), поэтому для него создавать отдельную сущность не обязательно, можно просто использовать готовую, и указывать ее во всех нужных связях.

Миграциями создается ряд таблицЮ который выглядит следуюшим образом:
auth_user (встроенная таблица user в авторизации)
catalog_category (название всей схемы, затем название таблицы)
catalog_basket
catalog_basket_products (промежуточные таблицы многие ко многим)
остальные сущности.

Администрирование MySQL и оптимизация----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
План выполнения запросов:
Определяются отношения, которые задействованы в запросе, а также последовательность операций.
Для каждой операции показывается количество задействованных кортежей, а также использование ключей (фактических и возможных).

Стратегия составления плана выполнения запроса MySQL:
Выбирается, с какой таблицы начать - выбирается таблица с минимумом картежей (следующая таблица выбирается по такому же принципу).
После выбираются условия, которые отсеивают максимальное количество кортежей, чтоб осталось меньше для обработки (следующее условие выбирается также).
Определяются ключи, которые позволят отсеить максимум кортежей, не сканируя таблицу полностью.

Команда explain перед запросом позволяет посмотреть план его выполнения, чтобы выбрать средства оптимизации (индексы).


Данные быстрее всего ищутся в упорядоченном состоянии. При изменении таблицы также можно использовать дерево, чтоб порядок не сломался.
Индекс - это и есть реализация дерева в sql.
Они позволяют оптимизировать работу БД, не сканируя таблицы целиком.
Кластерный индекс - упорядоченное дерево, листья которого - данные (может быть только один у таблицы, потому что меняет порядок хранения на самом жестком диске, а значит, порядок может быть только один).
Некластерные индексы - структуры, выстраиваиваемые вокруг данных со ссылками на кортежи (не меняют то, как будут храниться данные, нужны, если в запросе указывается не первичный ключ, а что-то еще, хранят ссылки на кортежи).
Некластерные индексы работают медленнее, потому что нужно сначала найти ссылку на нужный кортеж, а потом получить данные в кластерном индексе.

В реляционных системах по умолчанию для индексации используется B-дерево (для обоих видов индексов).
В узлах хранятся ключи с данными в виде чисел, между этими ключами - ссылки на узлы, в которых лежат ключи между этими двумя (в корне 5 и 10, ссылка между ними ведет на 6 и 8, а ссылка между ними может вести к 7, получается порядок).
Ищутся эти промежутки бинарным поиском, поэтому сложность такого поиска логарифмическая.

Такая система подходит для:
Операций сравнения.
Проверки на неопределенность (один из узлом обязательно должен быть null).
Сортировки или группировки, если повесить индекс на поля, по которым сортировка/группировка проходит.

Вторыми по популярности в СУБД являются хэш индексы.
Создается хэш таблица из упорядоченных корзин данных, если мы ищем два разных значения, и они указывают на один номер в хэш таблице, их объединяют в корзину (если корзина большая, скорость снижается).

Подходит такая индексация для:
Сравнений == или !=.
Проверки вхождения одного списка в другой (WHERE field_name IN(...))
Используется во внешних ключах.

Другие, специализированные типы индексов:
Геолокация.
Перекрывающие индексы.
Многомерные стрктуры.
Битовые индексы.


Индексы создают ключи, которые СУБД может использовать в плане запроса.
СУБД по умолчанию выбирает наиболее подходящий ключ среди доступных индексов, но пользователь может при помощи хинтов указать СУБД, какой ключ лучше использовать.

Пример использования индекса:

SELECT
  * 
FROM
  good
WHERE name like 'Zen%';

В данном случае будет происходить сравнение по всем кортежам таблицы поля name с паттерном.

Добавив индекс по полю name в данной таблице мы значительно ускорим работу, и задействоваться уже будет всего один кортеж (или больше, если они удовлетворяют паттерну):
CREATE INDEX good_name_index ON good(name);

Удаляются индексы так:
DROP INDEX good_name_index ON good;

Если же мы ищем не по паттерну, а по полному значению имени, то поиск будет проходить еще быстрее.
В случае, если наш паттерн выглядит так: '%endon' (начинается с %), индекс не сработает, и все еще будет проходить поиск через ALL.

NoSQL------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Переводится как not only sql, то есть, можно использовать для некоторых задач нереляционные СУБД совместно с реляционными.

Причины возникновения NoSQL решений:
Потребность в распределенных СУБД (при масштабировании БД реляционные модели начинают плохо работать)
Потребность в быстрой работе с данными (отказ от универсального доступа к данным посредством sql в угоду быстродействию)
Некоторые частые задачи можно моделировать проще, нежели через табличное представление (например, документ со списками в РСУБД был бы представлен в виде множества сущностей, по одной на список, в то время как в NoSQL они были бы внутри сущности документа).

Такие системы обычно создаются для каких-то конкретных задач.

Особенности NoSQL:
Объект данных - более сложная структура, чем просто у строки в таблице (может хранить вложенные документы или разные структуры, вроде словарей).
Без строго определенной схемы (в таком виде сложным структурам тяжело существовать, поэтому банки не используют их).
Без операций JOIN.
Масштабируемость.
Отсутствие SQL, но может быть похожий сокращенный аналог.

CAP-теорема:
Теорема гласит, что для распределенных систем можно выбрать только два свойства из возможных трех - consistency, availability, partition tolerance (CAP).
Consistency - информация на разных узлах системы синхронизирована (выполнив транзакцию на одном сервере (узле) можно увидеть ее результат и на других серверах).
Availability - доступность, то есть, система может отвечать на запросы пользователей.
Partition tolerance - терпимость к тому, что некоторые узлы могут отказывать. В случае обрыва СУБД сама справляется с этим.

Для реляционных СУБД обычно выбираются C и A, в то время как для нереляционных СУБД - C и P.

Со временем CAP система привела к рождению универасльных правил, по которым действует большинство СУБД.
Это BASE архитектура:
Basicaly available - означает, что система в случае сбоя узла отказывает только части пользователей (то есть, сбой приводит только к частичному выходу из строя системы).
Soft-state - система может находиться в некотором неустойчивом состоянии, но она должна пытаться самостоятельно оттуда выбраться (к таким состояниям относят, например, незавершенные транзакции).
Eventual consistancy - значит, что данные на разных серверах синхронизируются рано или поздно. То есть, допускается, что могут быть моменты несогласованности сразу после внесения изменений, но это временно.

НРСУБД типа ключ-значение используется для:
Работы с данным в реиме реального времени (чаты, игры и прочее).
Кэширование результатов долгих и частых операций (например, выборка категорий магазина, они не часто меняются, и есть смысл просто сохранить результат).
Организации некой файловой системы на основе ключ-значение, где ключ - путь к файлу, а значение - сам файл.

Примеры таких СУБД: Berkeley DB (80ые, одна из первых), Memcache (используется для реализации кэширования), Redis (самая популярная, для работы с файлами в реальном времени, реализации файловых систем, и большинства задач для таких систем).

Документоориентированные НРСУБД используются для:
Хранения документов так, чтоб по ним можно было проводить поиск.
Реализации информационных ресурсов (в новости может быть много атрибутов, тегов, комментариев, и все это можно получить по одному запросу из одной сущности).
Хранения данных с нечеткой схемой хранения.

Примеры: MongoDB (появилась для работы с таргетированной рекламой, яркий пример нечеткой схемы хранения), CouchDB (призвана упростить масштабирование).

СУБД семейства столбцов используется для использования в поисковиках и работе с огромными сущностями (по сути, это документоориентированная СУБД для огромных данных, поэтому они распределяются между множеством узлов):
Хранения данных, собранных с веб-страниц.
Хранение и поиск по большому объему данных.

Примеры: Big Table (первая такая СУБД, разработанная гуглом), Cassandra и HBAse (открытые варианты).

Обзор key-value СУБД Redis---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Данная СУБД самая быстрая (до 100к операций в секунду на одном узле), потому что целиком хранится в ОЗУ.
Однако, в случае сбоя все, что было в ОЗУ, пропадет, поэтому он периодически делает свои слепки на жестком диске.

Redis масштабируем, поскольку может работать в распределенном режиме, и иметь множество узлов.
Всего чуть больше сотни команд.
Для каждого типа данных свои команды, различаются они префиксами, вроде LPOP (для list), SPOP (для set).
Все команды работы с данными содержат ключ.

Типы данных Redis:
Вместо таблиц и баз данных оперирует наборами данных (вроде таблиц).
Ключ - уникальная строка для одного набора данных.
Значение и его 5 типов данных:
Строки - скалярные значения.
Хэши - хранит в значении хэш таблицу (словарь внутри словаря).
Списки - аналогичны спискам в python, вместе с их операциями.
Множества - аналогичны set в python с их операциями.
Упорядоченные множества - уникальные значения, которые можно каким-либо образом ранжировать (по дате, популярности и т.д.).

Вторая сильная сторона Redis - механизм репликации (масштабирования).
Есть мастер сервер, который единственный получает данные на изменение.
После этого он посылает обновления другим серверам, которые работают только на чтение, которые тоже начинают делиться обновлениями с другими slave серверами, разгружая мейн (в memcache дочерние узлы не могут так, мейн передает всем).
Так как изменения всегда атомарны (просты), передаются не операции, а уже обновленные значения.

Механизм подписок PubSub:
Вместо того, чтоб дочерние сервера мониторили состояние мейна на наличие изменений, можно подписаться на них, тогда мейн сам передаст изменения при их наличии, что уменьшает количество запросов и разгружает трафик между узлами.

Обзор документоориентированной СУБД MongoDB----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Особенности MongoDB:
Самая популярная из документоориентированных, поддерживается больше всего, поэтому самая стабильная.
Простота хранения данных, потому что нет проблем с миграциями.
При этом язык запросов - js, а точнее, JSON, что сразу и хорошо, и плохо, поскольку сложно читаем, но легко сделать интерпретатор, поэтому есть множество ORM под любые языки.

Пользовательские команды:
Валидный JSON. Из-за скобок сложно читаем без подсветки синтаксиса, не все символы можно использовать.
Однако, легко найти драйвер с подходящим синтаксисом в любом языке.

Что придумано вместо JOIN:
Можно указывать в нужных объектах ссылки на другой объект, в котором произойдет объединение, но это сложно, требует нескольких запросов, и работает не совсем, как JOIN.
Другой способ - встраивание документов. Такой способ делает систему ненормализованной, возможны аномалии. Нужные объекты, если они не велики могут встраиваться в объект документа, но таким образом данные будут дублироваться.

DBRef:
Позволяют использовать JOIN средствами драйверов и ORM.
DBRef("user", ObjectId('...')) примерно так он используется.

Репликация работает так же, как в memcache, без связи между дочерними узлами.
Но есть особенность, защита от отключения master узла. В таком случае СУБД назначает один из дочерних узлов мастером.