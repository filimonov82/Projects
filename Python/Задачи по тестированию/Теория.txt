Selenium — это open-source проект, который предназначен главным образом для автоматизации тестирования веб-приложений.
Проект состоит из множества компонентов, как Selenium IDE, Grid, Server, WebDriver и т.д.

В данном курсе мы будем работать с Selenium WebDriver - интерфейсом взаимодействия клиентского кода (тестов) с браузером (через драйверы).
Данный инструмент позволяет писать тесты на любом ЯП (наиболее популярны для него Java и Python) под любой браузер при помощи драйвера, который разрабатывают под selenium 
разработчики браузера.

В итоге, написанные тесты, по большей части, универсальны, и подходят для любого браузера.
Таким образом, WebDriver признали стандартом протокола взаимодействия с браузером.

Для выполнения определенных действий на веб странице необходимо понимать ее структуру.
Элементы внутри страницы можно найти несколькими способами:
1. Поиск с помощью CSS-селекторов, когда путь к элементу описывается через синтаксис CSS. Селектор — это описание пути к элементу на странице.
2. Поиск с помощью указания значений тегов или атрибутов элементов: ID, class, и т.д.
3. Поиск с помощью языка запросов XPath.

Поиск с помощью css селекторов покрывает практически все возможные ситуации, и выглядит достаточно читабельным, поэтому он нас интересует в первую очередь.
Однако не редки случаи, когда другие способы в приоритете (css не умеет искать вверх, поэтому не подходит для поиска предков).

css селектор:
button {
  color:green;
}

html тэг:
<p>Текст</p>

Атрибуты тэгов:
Атрибут class - <div class="simple-text main">Здесь написан текст.</div>
У данного элемента имеется два класса, simple-text и main. Классы обычно используются для использования в css.

Атрибут name - <a name="top"></a>
Данный атрибут можно использовать в качестве якоря (закладки для перехода к нему через href="#top"), а также для поиска элемента.

Атрибут id - <button id="save_button">Сохранить</button>
Это уникальный указатель на элемент, в пределах страницы id не должны повторяться.

!Важно. В современных JavaScript-фреймворках id-атрибуты чаще всего генерируются динамически самим фреймворком, поэтому
они изменяются каждый раз при перезагрузке страницы и совершенно нечитабельны, например: вы увидите что-то вроде
id="u_ps_0_0_n" или id="avadspffd". В таких случаях вам придется пользоваться другими селекторами или использовать собственные
data-атрибуты, о которых мы расскажем далее. Названия классов также могут генерироваться автоматически. Поэтому предлагаем
вам простое правило: если увидите нечеловекочитаемое значение атрибута или если значение атрибута меняется при перезагрузке
страницы, то не используйте его.

data-атрибуты:
Это специальные атрибуты для тестов, которые не изменяются, как правило, начинаются с data-, и которые разработчик по договоренности может добавить.

Поиск элементов с помощью CSS селекторов.-----------------------------------------------------------------------------------------------------------------------------------------------
Части html страницы, по которым можно найти элемент:
id, tag, name, class, значение атрибута.

Поиск по id - если у элемента есть id, например, id="bullet", то для его поиска есть селектор #bullet, который можно ввести в поиске панели элемента (ctrl f), или в коде.

Поиск по tag - для такого поиска вводим сам тэг, например, h1, но это не очень удобно, так как обычно на странице множество одинаковых тэгов.

Поиск по значению атрибута - указываем атрибут и его значение в [] - [id="bullet"].

Поиск по name - это разновидность поиска по значению атрибута, и записывается также, но, естественноЮ атрибут тут name. Это довольно частый вид поиска, и в WebDriver выдеояется в отдельный вид.

Поиск по class - тоже разновидность поиска по значению атрибута и может записываться в [], но в таком случае, если у атрибута несколько классов, то надо писать их все в точном порядке,
иначе элемент не будет найден. Но мы можем писать упрощенно, так как это очень частоиспользуемый атрибут в css, написав значение атрибута и предварив его точкой .value
В таком виде ищется просто вхождение, поэтому можно указать только один из классов, или все в любом порядке вот так: .value1.value2
Однако стоит помнить, что такой поиск чувствителен к регистру, и .Value это уже другой класс.

Поиск с помощью составных CSS селекторов.-----------------------------------------------------------------------------------------------------------------------------------------------
<div id="posts" class="post-list">
  <div id="post1" class="item">
    <div class="title">Как я провел лето</div>
    <img src="./images/summer.png">
  </div>
  <div id="post2" class="item">
    <div class="title second">Ходили купаться</div>
    <img src="./images/bad_dog.jpg">
  </div>
  <div id="post3" class="item">
    <div class="title">С друзьями</div>
    <img src="./images/friends.jpg">
  </div>
</div>

Если бы мы хотели найти здесь элемент с текстов Ходили купаться, мы могли бы воспользоваться составным селектором, то есть, селектором с разными атрибутами.
#post2 .title - такой селектор нам подходит. Он значит, что мы ищем элемент с id post2, пробел значит, что следуюший селектор - потомок первого, 
и ищется класс title во всех детях этого элемента.
Если же мы не поставим пробела, то ничего не найдется, потому что будет искаться элемент и с таким id, и с таким классом, а таких нет.

Другой способ - #post2 > div.title - здесь мы указали еще тег элемента div и уточнили, что нужно взять элемент с тегом и классом: div.title,
который находится строго на один уровень иерархии ниже чем элемент #post2. Для этого используется символ > (символ > может обособляться пробелами, а может нет, это не учитывается).

Еще один способ найти этот элемент - #posts > .item:nth-child(2) > .title - Псевдо-класс :nth-child(2) — позволяет найти второй по порядку элемент среди дочерних элементов для #posts.
Затем с помощью конструкции > .title мы указываем, что нам нужен элемент .title, родителем которого является найденный ранее элемент .item.

Поиск элементов с помощью XPath---------------------------------------------------------------------------------------------------------------------------------------------------------
Если разработчик не идет на встречу с добавлением data атрибутов, приходится выкручиваться самому.
XPath (XML Path Language) это язык запросов, который использует древовидную структуру документа, то есть, все работает через /.
/ в данном случае обращается к прямому потомку (как >), а // - ко всем потомкам (как пробел).
Корневой элемент всегда <html>, /html/body/header - пример использования.
//div найдет все тэги div.

Символ [] — это команда фильтрации. Если найдено много результатов, используем это.
Поиск по атрибуту - //img[@id='bullet'] (@ в данном случае обпределяет id как атрибут, атрибут может быть любым).
По порядковому номеру - //div[@class="row"]/div[2] - находим div элемент с классом row, и обращаемся к его второму дочернему элементу (как :nth-child(2)).
По полному совпадению внутреннего текста (только XPath так может) - //p[text()="Lenin cat"] - но это не всегда хорошая практика, особенно на мультиязычных сайтах, поскольку надо точное совпадение.
По частичному совпадению текста или атрибута при помощи функции contains() - //p[contains(text(), "cat")] - ищется текст, содержащий слово cat.
Также это можно использовать для частичного совпадения атрибутов, например, классов, когда их много - //div[contains(@class, "navbar")].
Можно также использовать булевы операции and, or, not и арифметические операции - //img[@name='bullet-cat' and @data-type='animal'].

Знак * - выбор всех элементов - //div/*[@class="jumbotron-heading"].
Поиск через XPath также регистрозависим.

Поиск элементов с помощью selenium------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Для поиска используется метод find_element, который принимает два аргумента - тип локатора и его значение.
Для его использования надо импортировать компонент webdriver из selenium и класс by, чтобы подключить все типы локаторов.
Под локатором понимается стратегия поиска (какой вид поиска).

from selenium import webdriver
from selenium.webdriver.common.by import By

Способы поиска:
find_element(By.ID, value) - поиск по атрибуту id. Если разработчики проставляют всем элементам в приложении уникальный id, то это наиболее удобный и стабильный метод.
find_element(By.CSS_SELECTOR, value) - поиск с помощью правил на основе CSS. Этот способ можно считать универсальным методом поиска, поскольку почти все сайты используют в своей структуре CSS для верстки.
Это наиболее вероятный способ для поиска после id.
find_element(By.XPATH, value) - поиск через XPath.
find_element(By.NAME, value) - поиск по атрибуту name.
find_element(By.TAG-NAME, value) - поиск по тэгу.
find_element(By.CLASS_NAME, value) - поиск по классу.
find_element(By.LINK_TEXT, value) - поиск ссылки на странице по полному совпадению.
find_element(By.PARTIAL_LINK_TEXT, value) - поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки.

Пример поиска по id элемента:

from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element(By.ID, "submit_button")

В случае, если условиям поиска будет соответствовать несколько элементов на странице, данный метод вернет только первое вхождение.
Чтобы избежать подобной проблемы, нужно либо написать более подробный селектор, либо использовать метод find_elements (во множественном числе). Данный метод будет рассмотрен позже.

Работа с браузером в Selenium------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Браузер не всегда закрывается автоматически после эмуляции, поэтому его надо закрывать явно через метод browser.quit()
Каждый раз при создании браузера через метод webdriver.Chrome() создается отдельный процесс, который останется висеть в системе, если закрыть окно бразуера вручную.
Таким образом, для того, чтобы не исчерпать всю ОЗУ, надо закрывать процессы вручную.

from selenium import webdriver
from selenium.webdriver.common.by import By


link = "http://suninjuly.github.io/simple_form_find_task.html"
browser = webdriver.Chrome()
browser.get(link)
button = browser.find_element(By.ID, "submit_button")
button.click()

# закрываем браузер после всех манипуляций
browser.quit()

Помимо метода .quit() существует также метод .close(), но он закрывает только текущее активное окно, в то время как .quit() останавливает все процессы webdriverа.

Может случиться так, что код не дойдет до конца, где вызывается данный метод, упав по пути с исключением.
На такой случай можно воспользоваться конструкцией try/finally.

from selenium import webdriver
from selenium.webdriver.common.by import By

link = "http://suninjuly.github.io/simple_form_find_task.html"

try:
    browser = webdriver.Chrome()
    browser.get(link)
    button = browser.find_element(By.ID, "submit_button")
    button.click()

finally:
    # закрываем браузер после всех манипуляций
    browser.quit()

Даже если код в блоке try бросит исключение, код в блоке finally выполнится. Подробнее об обработке исключений будет в будущих уроках, в том числе с использованием более лаконичных конструкций.

Также хорошей практикой считается добавление пустой строки в конце скрипта, так как системы UNIX/Linux их ожидают, и в случае отсутствия последняя строка с кодом может не выполниться.

Пример поиска по тексту ссылки:
link = browser.find_element(By.LINK_TEXT, "Degree Symbol in Math")
link.click()

Пример поиска по части текста ссылки:
link = browser.find_element(By.PARTIAL_LINK_TEXT, "Math")
link.click()

Такой поиск, обычно, более гибок, однако, используя его, нужно быть осторожным, поскольку можно легко выйти не на тот элемент.

