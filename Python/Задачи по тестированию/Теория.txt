Selenium — это open-source проект, который предназначен главным образом для автоматизации тестирования веб-приложений.
Проект состоит из множества компонентов, как Selenium IDE, Grid, Server, WebDriver и т.д.

В данном курсе мы будем работать с Selenium WebDriver - интерфейсом взаимодействия клиентского кода (тестов) с браузером (через драйверы).
Данный инструмент позволяет писать тесты на любом ЯП (наиболее популярны для него Java и Python) под любой браузер при помощи драйвера, который разрабатывают под selenium 
разработчики браузера.

В итоге, написанные тесты, по большей части, универсальны, и подходят для любого браузера.
Таким образом, WebDriver признали стандартом протокола взаимодействия с браузером.

Для выполнения определенных действий на веб странице необходимо понимать ее структуру.
Элементы внутри страницы можно найти несколькими способами:
1. Поиск с помощью CSS-селекторов, когда путь к элементу описывается через синтаксис CSS. Селектор — это описание пути к элементу на странице.
2. Поиск с помощью указания значений тегов или атрибутов элементов: ID, class, и т.д.
3. Поиск с помощью языка запросов XPath.

Поиск с помощью css селекторов покрывает практически все возможные ситуации, и выглядит достаточно читабельным, поэтому он нас интересует в первую очередь.
Однако не редки случаи, когда другие способы в приоритете (css не умеет искать вверх, поэтому не подходит для поиска предков).

css селектор:
button {
  color:green;
}

html тэг:
<p>Текст</p>

Атрибуты тэгов:
Атрибут class - <div class="simple-text main">Здесь написан текст.</div>
У данного элемента имеется два класса, simple-text и main. Классы обычно используются для использования в css.

Атрибут name - <a name="top"></a>
Данный атрибут можно использовать в качестве якоря (закладки для перехода к нему через href="#top"), а также для поиска элемента.

Атрибут id - <button id="save_button">Сохранить</button>
Это уникальный указатель на элемент, в пределах страницы id не должны повторяться.

!Важно. В современных JavaScript-фреймворках id-атрибуты чаще всего генерируются динамически самим фреймворком, поэтому
они изменяются каждый раз при перезагрузке страницы и совершенно нечитабельны, например: вы увидите что-то вроде
id="u_ps_0_0_n" или id="avadspffd". В таких случаях вам придется пользоваться другими селекторами или использовать собственные
data-атрибуты, о которых мы расскажем далее. Названия классов также могут генерироваться автоматически. Поэтому предлагаем
вам простое правило: если увидите нечеловекочитаемое значение атрибута или если значение атрибута меняется при перезагрузке
страницы, то не используйте его.

data-атрибуты:
Это специальные атрибуты для тестов, которые не изменяются, как правило, начинаются с data-, и которые разработчик по договоренности может добавить.

Поиск элементов с помощью CSS селекторов.-----------------------------------------------------------------------------------------------------------------------------------------------
Части html страницы, по которым можно найти элемент:
id, tag, name, class, значение атрибута.

Поиск по id - если у элемента есть id, например, id="bullet", то для его поиска есть селектор #bullet, который можно ввести в поиске панели элемента (ctrl f), или в коде.

Поиск по tag - для такого поиска вводим сам тэг, например, h1, но это не очень удобно, так как обычно на странице множество одинаковых тэгов.

Поиск по значению атрибута - указываем атрибут и его значение в [] - [id="bullet"].

Поиск по name - это разновидность поиска по значению атрибута, и записывается также, но, естественноЮ атрибут тут name. Это довольно частый вид поиска, и в WebDriver выдеояется в отдельный вид.

Поиск по class - тоже разновидность поиска по значению атрибута и может записываться в [], но в таком случае, если у атрибута несколько классов, то надо писать их все в точном порядке,
иначе элемент не будет найден. Но мы можем писать упрощенно, так как это очень частоиспользуемый атрибут в css, написав значение атрибута и предварив его точкой .value
В таком виде ищется просто вхождение, поэтому можно указать только один из классов, или все в любом порядке вот так: .value1.value2
Однако стоит помнить, что такой поиск чувствителен к регистру, и .Value это уже другой класс.

Поиск с помощью составных CSS селекторов.-----------------------------------------------------------------------------------------------------------------------------------------------
<div id="posts" class="post-list">
  <div id="post1" class="item">
    <div class="title">Как я провел лето</div>
    <img src="./images/summer.png">
  </div>
  <div id="post2" class="item">
    <div class="title second">Ходили купаться</div>
    <img src="./images/bad_dog.jpg">
  </div>
  <div id="post3" class="item">
    <div class="title">С друзьями</div>
    <img src="./images/friends.jpg">
  </div>
</div>

Если бы мы хотели найти здесь элемент с текстов Ходили купаться, мы могли бы воспользоваться составным селектором, то есть, селектором с разными атрибутами.
#post2 .title - такой селектор нам подходит. Он значит, что мы ищем элемент с id post2, пробел значит, что следуюший селектор - потомок первого, 
и ищется класс title во всех детях этого элемента.
Если же мы не поставим пробела, то ничего не найдется, потому что будет искаться элемент и с таким id, и с таким классом, а таких нет.

Другой способ - #post2 > div.title - здесь мы указали еще тег элемента div и уточнили, что нужно взять элемент с тегом и классом: div.title,
который находится строго на один уровень иерархии ниже чем элемент #post2. Для этого используется символ > (символ > может обособляться пробелами, а может нет, это не учитывается).

Еще один способ найти этот элемент - #posts > .item:nth-child(2) > .title - Псевдо-класс :nth-child(2) — позволяет найти второй по порядку элемент среди дочерних элементов для #posts.
Затем с помощью конструкции > .title мы указываем, что нам нужен элемент .title, родителем которого является найденный ранее элемент .item.

Поиск элементов с помощью XPath---------------------------------------------------------------------------------------------------------------------------------------------------------
Если разработчик не идет на встречу с добавлением data атрибутов, приходится выкручиваться самому.
XPath (XML Path Language) это язык запросов, который использует древовидную структуру документа, то есть, все работает через /.
/ в данном случае обращается к прямому потомку (как >), а // - ко всем потомкам (как пробел).
Корневой элемент всегда <html>, /html/body/header - пример использования.
//div найдет все тэги div.

Символ [] — это команда фильтрации. Если найдено много результатов, используем это.
Поиск по атрибуту - //img[@id='bullet'] (@ в данном случае обпределяет id как атрибут, атрибут может быть любым).
По порядковому номеру - //div[@class="row"]/div[2] - находим div элемент с классом row, и обращаемся к его второму дочернему элементу (как :nth-child(2)).
По полному совпадению внутреннего текста (только XPath так может) - //p[text()="Lenin cat"] - но это не всегда хорошая практика, особенно на мультиязычных сайтах, поскольку надо точное совпадение.
По частичному совпадению текста или атрибута при помощи функции contains() - //p[contains(text(), "cat")] - ищется текст, содержащий слово cat.
Также это можно использовать для частичного совпадения атрибутов, например, классов, когда их много - //div[contains(@class, "navbar")].
Можно также использовать булевы операции and, or, not и арифметические операции - //img[@name='bullet-cat' and @data-type='animal'].

Знак * - выбор всех элементов - //div/*[@class="jumbotron-heading"].
Поиск через XPath также регистрозависим.

