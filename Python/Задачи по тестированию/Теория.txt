Selenium — это open-source проект, который предназначен главным образом для автоматизации тестирования веб-приложений.
Проект состоит из множества компонентов, как Selenium IDE, Grid, Server, WebDriver и т.д.

В данном курсе мы будем работать с Selenium WebDriver - интерфейсом взаимодействия клиентского кода (тестов) с браузером (через драйверы).
Данный инструмент позволяет писать тесты на любом ЯП (наиболее популярны для него Java и Python) под любой браузер при помощи драйвера, который разрабатывают под selenium 
разработчики браузера.

В итоге, написанные тесты, по большей части, универсальны, и подходят для любого браузера.
Таким образом, WebDriver признали стандартом протокола взаимодействия с браузером.

Для выполнения определенных действий на веб странице необходимо понимать ее структуру.
Элементы внутри страницы можно найти несколькими способами:
1. Поиск с помощью CSS-селекторов, когда путь к элементу описывается через синтаксис CSS. Селектор — это описание пути к элементу на странице.
2. Поиск с помощью указания значений тегов или атрибутов элементов: ID, class, и т.д.
3. Поиск с помощью языка запросов XPath.

Поиск с помощью css селекторов покрывает практически все возможные ситуации, и выглядит достаточно читабельным, поэтому он нас интересует в первую очередь.
Однако не редки случаи, когда другие способы в приоритете (css не умеет искать вверх, поэтому не подходит для поиска предков).

css селектор:
button {
  color:green;
}

html тэг:
<p>Текст</p>

Атрибуты тэгов:
Атрибут class - <div class="simple-text main">Здесь написан текст.</div>
У данного элемента имеется два класса, simple-text и main. Классы обычно используются для использования в css.

Атрибут name - <a name="top"></a>
Данный атрибут можно использовать в качестве якоря (закладки для перехода к нему через href="#top"), а также для поиска элемента.

Атрибут id - <button id="save_button">Сохранить</button>
Это уникальный указатель на элемент, в пределах страницы id не должны повторяться.

!Важно. В современных JavaScript-фреймворках id-атрибуты чаще всего генерируются динамически самим фреймворком, поэтому
они изменяются каждый раз при перезагрузке страницы и совершенно нечитабельны, например: вы увидите что-то вроде
id="u_ps_0_0_n" или id="avadspffd". В таких случаях вам придется пользоваться другими селекторами или использовать собственные
data-атрибуты, о которых мы расскажем далее. Названия классов также могут генерироваться автоматически. Поэтому предлагаем
вам простое правило: если увидите нечеловекочитаемое значение атрибута или если значение атрибута меняется при перезагрузке
страницы, то не используйте его.

data-атрибуты:
Это специальные атрибуты для тестов, которые не изменяются, как правило, начинаются с data-, и которые разработчик по договоренности может добавить.

Поиск элементов с помощью CSS селекторов.-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Части html страницы, по которым можно найти элемент:
id, tag, name, class, значение атрибута.

Поиск по id - если у элемента есть id, например, id="bullet", то для его поиска есть селектор #bullet, который можно ввести в поиске панели элемента (ctrl f), или в коде.

Поиск по tag - для такого поиска вводим сам тэг, например, h1, но это не очень удобно, так как обычно на странице множество одинаковых тэгов.

Поиск по значению атрибута - указываем атрибут и его значение в [] - [id="bullet"].

Поиск по name - это разновидность поиска по значению атрибута, и записывается также, но, естественноЮ атрибут тут name. Это довольно частый вид поиска, и в WebDriver выдеояется в отдельный вид.

Поиск по class - тоже разновидность поиска по значению атрибута и может записываться в [], но в таком случае, если у атрибута несколько классов, то надо писать их все в точном порядке,
иначе элемент не будет найден. Но мы можем писать упрощенно, так как это очень частоиспользуемый атрибут в css, написав значение атрибута и предварив его точкой .value
В таком виде ищется просто вхождение, поэтому можно указать только один из классов, или все в любом порядке вот так: .value1.value2
Однако стоит помнить, что такой поиск чувствителен к регистру, и .Value это уже другой класс.

Поиск с помощью составных CSS селекторов.-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<div id="posts" class="post-list">
  <div id="post1" class="item">
    <div class="title">Как я провел лето</div>
    <img src="./images/summer.png">
  </div>
  <div id="post2" class="item">
    <div class="title second">Ходили купаться</div>
    <img src="./images/bad_dog.jpg">
  </div>
  <div id="post3" class="item">
    <div class="title">С друзьями</div>
    <img src="./images/friends.jpg">
  </div>
</div>

Если бы мы хотели найти здесь элемент с текстов Ходили купаться, мы могли бы воспользоваться составным селектором, то есть, селектором с разными атрибутами.
#post2 .title - такой селектор нам подходит. Он значит, что мы ищем элемент с id post2, пробел значит, что следуюший селектор - потомок первого, 
и ищется класс title во всех детях этого элемента.
Если же мы не поставим пробела, то ничего не найдется, потому что будет искаться элемент и с таким id, и с таким классом, а таких нет.

Другой способ - #post2 > div.title - здесь мы указали еще тег элемента div и уточнили, что нужно взять элемент с тегом и классом: div.title,
который находится строго на один уровень иерархии ниже чем элемент #post2. Для этого используется символ > (символ > может обособляться пробелами, а может нет, это не учитывается).

Еще один способ найти этот элемент - #posts > .item:nth-child(2) > .title - Псевдо-класс :nth-child(2) — позволяет найти второй по порядку элемент среди дочерних элементов для #posts.
Затем с помощью конструкции > .title мы указываем, что нам нужен элемент .title, родителем которого является найденный ранее элемент .item.

Поиск элементов с помощью XPath---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Если разработчик не идет на встречу с добавлением data атрибутов, приходится выкручиваться самому.
XPath (XML Path Language) это язык запросов, который использует древовидную структуру документа, то есть, все работает через /.
/ в данном случае обращается к прямому потомку (как >), а // - ко всем потомкам (как пробел).
Корневой элемент всегда <html>, /html/body/header - пример использования.
//div найдет все тэги div.

Символ [] — это команда фильтрации. Если найдено много результатов, используем это.
Поиск по атрибуту - //img[@id='bullet'] (@ в данном случае обпределяет id как атрибут, атрибут может быть любым).
По порядковому номеру - //div[@class="row"]/div[2] - находим div элемент с классом row, и обращаемся к его второму дочернему элементу (как :nth-child(2)).
По полному совпадению внутреннего текста (только XPath так может) - //p[text()="Lenin cat"] - но это не всегда хорошая практика, особенно на мультиязычных сайтах, поскольку надо точное совпадение.
По частичному совпадению текста или атрибута при помощи функции contains() - //p[contains(text(), "cat")] - ищется текст, содержащий слово cat.
Также это можно использовать для частичного совпадения атрибутов, например, классов, когда их много - //div[contains(@class, "navbar")].
Можно также использовать булевы операции and, or, not и арифметические операции - //img[@name='bullet-cat' and @data-type='animal'].

Знак * - выбор всех элементов - //div/*[@class="jumbotron-heading"].
Поиск через XPath также регистрозависим.

Поиск элементов с помощью selenium------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Для поиска используется метод find_element, который принимает два аргумента - тип локатора и его значение.
Для его использования надо импортировать компонент webdriver из selenium и класс by, чтобы подключить все типы локаторов.
Под локатором понимается стратегия поиска (какой вид поиска).

from selenium import webdriver
from selenium.webdriver.common.by import By

Способы поиска:
find_element(By.ID, value) - поиск по атрибуту id. Если разработчики проставляют всем элементам в приложении уникальный id, то это наиболее удобный и стабильный метод.
find_element(By.CSS_SELECTOR, value) - поиск с помощью правил на основе CSS. Этот способ можно считать универсальным методом поиска, поскольку почти все сайты используют в своей структуре CSS для верстки.
Это наиболее вероятный способ для поиска после id.
find_element(By.XPATH, value) - поиск через XPath.
find_element(By.NAME, value) - поиск по атрибуту name.
find_element(By.TAG-NAME, value) - поиск по тэгу.
find_element(By.CLASS_NAME, value) - поиск по классу.
find_element(By.LINK_TEXT, value) - поиск ссылки на странице по полному совпадению.
find_element(By.PARTIAL_LINK_TEXT, value) - поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки.

Пример поиска по id элемента:

from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element(By.ID, "submit_button")

В случае, если условиям поиска будет соответствовать несколько элементов на странице, данный метод вернет только первое вхождение.
Чтобы избежать подобной проблемы, нужно либо написать более подробный селектор, либо использовать метод find_elements (во множественном числе). Данный метод будет рассмотрен позже.

Работа с браузером в Selenium---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Браузер не всегда закрывается автоматически после эмуляции, поэтому его надо закрывать явно через метод browser.quit()
Каждый раз при создании браузера через метод webdriver.Chrome() создается отдельный процесс, который останется висеть в системе, если закрыть окно бразуера вручную.
Таким образом, для того, чтобы не исчерпать всю ОЗУ, надо закрывать процессы вручную.

from selenium import webdriver
from selenium.webdriver.common.by import By


link = "http://suninjuly.github.io/simple_form_find_task.html"
browser = webdriver.Chrome()
browser.get(link)
button = browser.find_element(By.ID, "submit_button")
button.click()

# закрываем браузер после всех манипуляций
browser.quit()

Помимо метода .quit() существует также метод .close(), но он закрывает только текущее активное окно, в то время как .quit() останавливает все процессы webdriverа.

Может случиться так, что код не дойдет до конца, где вызывается данный метод, упав по пути с исключением.
На такой случай можно воспользоваться конструкцией try/finally.

from selenium import webdriver
from selenium.webdriver.common.by import By

link = "http://suninjuly.github.io/simple_form_find_task.html"

try:
    browser = webdriver.Chrome()
    browser.get(link)
    button = browser.find_element(By.ID, "submit_button")
    button.click()

finally:
    # закрываем браузер после всех манипуляций
    browser.quit()

Даже если код в блоке try бросит исключение, код в блоке finally выполнится. Подробнее об обработке исключений будет в будущих уроках, в том числе с использованием более лаконичных конструкций.

Также хорошей практикой считается добавление пустой строки в конце скрипта, так как системы UNIX/Linux их ожидают, и в случае отсутствия последняя строка с кодом может не выполниться.

Пример поиска по тексту ссылки:
link = browser.find_element(By.LINK_TEXT, "Degree Symbol in Math")
link.click()

Пример поиска по части текста ссылки:
link = browser.find_element(By.PARTIAL_LINK_TEXT, "Math")
link.click()

Такой поиск, обычно, более гибок, однако, используя его, нужно быть осторожным, поскольку можно легко выйти не на тот элемент.

Поиск множества одинаковых элементов-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Метод .find_elements возвращает список из всех найденных элементов, если элементы не найдены, возвращается пустой список (в то время как find_element бросает исключение).

# подготовка для теста
# открываем страницу первого товара
# данный сайт не существует, этот код приведен только для примера
browser.get("https://fake-shop.com/book1.html")

# добавляем товар в корзину
add_button = browser.find_element(By.CSS_SELECTOR, ".add")
add_button.click()

# открываем страницу второго товара
browser.get("https://fake-shop.com/book2.html")

# добавляем товар в корзину
add_button = browser.find_element(By.CSS_SELECTOR, ".add")
add_button.click()

# тестовый сценарий
# открываем корзину
browser.get("https://fake-shop.com/basket.html")

# ищем все добавленные товары
goods = browser.find_elements(By.CSS_SELECTOR, ".good")

# проверяем, что количество товаров равно 2
assert len(goods) == 2

Уникальность селекторов-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Идеальный селектор - тот, что позволяет найти только один искомый элемент.
Уникальные селекторы делают тесты стабильными и менее зависимыми от верстки.

Хороший тест - тот, что проверяет атомарную часть функциональности, а не все и сразу. Благодаря таким тестам мы быстрее локализуем баг, в то время как большой тест при падении
укажет только на первую ошибку.

Рассмотрим следующий пример: у нас есть форма регистрации, в которой есть обязательные и необязательные поля для заполнения. Нужно проверить, что можно успешно зарегистрироваться на сайте.

Сценарий плохого автотеста:

1

Открыть страницу с формой
Заполнить все поля
Нажать кнопку "Регистрация"
Проверить, что есть сообщение об успешной регистрации
Лучше разбить предыдущий тест на набор более простых автотестов:

1

Открыть страницу с формой
Заполнить только обязательные поля
Нажать кнопку "Регистрация"
Проверить, что есть сообщение об успешной регистрации
2

Открыть страницу с формой
Заполнить все обязательные поля
Заполнить все необязательные поля
Нажать кнопку "Регистрация"
Проверить, что есть сообщение об успешной регистрации
3

Открыть страницу с формой
Заполнить только необязательные поля
Проверить, что кнопка "Регистрация" неактивна

Assert в наших тестах ищет баги, если он бросает исключение, то найден баг, а если нет, то все в порядке.

Для того, чтоб следующая страница успевала загрузиться, мы ставим time.sleep(), однако это считается плохой практикой, поскольку неизвестно, сколько нужно ждать, в будущем
будут показаны более подходящие конструкции, а пока пользуемся этим.

Работа с элементами типа checkbox и radiobutton------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Checkbox (чекбокс или флажок) и radiobutton (радиобаттон или переключатель) — часто используемые в формах элементы.
Основная разница между ними состоит в том, что флажки позволяют выбирать/отключать любой из представленных вариантов, а
переключатели позволяют выбрать только один из вариантов. Далее мы будем называть эти элементы на англоязычный манер: checkbox и radiobutton.

Оба этих элемента создаются при помощи тега input со значением атрибута type равным checkbox или radio соответственно:
<input type="checkbox">
<input type="radio">

Если checkbox или radiobutton выбран, то у элемента появится новый атрибут checked без значения. Часто атрибут checked уже установлен для одного из элементов по умолчанию:
<input type="checkbox" checked>
<input type="radio" checked>

Radiobuttons объединяются в группу, где все элементы имеют одинаковые значения атрибута name, но разные значения атрибута value:
<input type="radio" name="language" value="python" checked>
<input type="radio" name="language" value="selenium">

Checkboxes могут иметь как одинаковые, так и разные значения атрибута name. Поэтому и те, и другие лучше искать с помощью значения id или значения атрибута value.

Выбираются такие элементы через .click()

Также вы можете увидеть тег label рядом с input. Этот тег используется, чтобы сделать кликабельным текст, который отображается
рядом с флажком. Этот текст заключен внутри тега label. Элемент label связывается с элементом input с помощью атрибута for, в
котором указывается значение атрибута id для элемента input:
<div>
  <input type="radio" id="python" name="language" checked>
  <label for="python">Python</label>
</div>
<div>
  <input type="radio" id="java" name="language">
  <label for="java">Java</label>
</div>

Тогда .click() работает и на lable.

Метод get_attribute()--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Мы можем применить данный метод к найденному элементу для уточнения значения, либо наличия указанного атрибута.
people_checked = people_radio.get_attribute("checked")  - проверяем, выбрано ли значение по-умолчанию, по наличию аттрибута checked.
print("value of people radio: ", people_checked)
assert people_checked is not None, "People radio is not selected by default" - если аттрибут не найден, возвращается None

Если аттрибут найден, то возвращается 'true' от js (с маленькой буквы), так что, можно организовать проверку так:
assert people_checked == "true", "People radio is not selected by default"

Работа со списками-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
На веб-страницах мы также встречаем раскрывающиеся (выпадающие) списки. У таких списков есть несколько важных особенностей:
1. У каждого элемента списка обычно есть уникальное значение атрибута value
2. В списках может быть разрешено выбирать как только один, так и несколько вариантов, в зависимости от типа списка
3. Визуально списки могут различаться тем, что в одном случае все варианты скрыты в выпадающем меню, а в другом все варианты или их часть видны

В html такие списки выглядят так:
<label for="dropdown">Выберите язык программирования:</label>
<select id="dropdown" class="custom-select">
 <option selected>--</option>
 <option value="1">Python</option>
 <option value="2">Java</option>
 <option value="3">JavaScript</option>
</select>

Варианты ответа задаются тегом option, значение value может отсутствовать. Можно отмечать варианты с помощью обычного
метода click(). Для этого сначала нужно применить метод click() для элемента с тегом select, чтобы список раскрылся,
а затем кликнуть на нужный вариант ответа.

browser.find_element(By.TAG_NAME, "select").click()
browser.find_element(By.CSS_SELECTOR, "option:nth-child(2)").click()

Также можно использовать специальный класс Select из библиотеки WebDriver:
from selenium.webdriver.support.ui import Select
select = Select(browser.find_element(By.TAG_NAME, "select"))
select.select_by_value("1") # ищем элемент с текстом "Python"

Для работы с полученным списком есть и другие методы - select.select_by_visible_text("text") и select.select_by_index(index).
Первый будет искать по содержанию варианта ответа, второй - по индексу в списке (нулевой за пустым значением по-умолчанию).

Метод execute_script---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
.execute_script позволяет в автотесте выполнять полноценный скрипт на js
Это может быть полезно, когда мы имеем дело с какими-то нестандартными вещами на страницах, поскольку на данный момент очень много инструментов доступно разработчикам,
и иногда для простого наатия кнопки требуется писать целый скрипт.

Проверить работу скрипта можно в консоли браузера, прежде, чем вставлять в тест.

Вызов алерта в браузере:
from selenium import webdriver
browser = webdriver.Chrome()
browser.execute_script("alert('Robots at work');")

Исполняемый js скрипт нужно брать в кавычки.
Через ; можно указать несколько команд.

Тривиальный пример необходимости этого метода - элемент перекрыт футером или другой частью сайта (куки запрос?), и нужно проскроллить ниже, чтоб нажать.
Но автоматически скроллиться не будет, и попытается нажать на перекрытый элемент, что бросит подробное исключение, в какой точке и какой элемент мешает.
В таком случае, можно использовать команду на js для скролла до тех пор, пока элемент не будет виден:

button = browser.find_element_by_tag_name("button")
browser.execute_script("return arguments[0].scrollIntoView(true);", button)
button.click()

В коде для WebDriver нужно использовать return, хотя в самом js, в данном случае, не нужно. Также мы используем return, когда нам нужно получить какие-то данные после исполнения скрипта.

Также можно проскроллить всю страницу целиком на строго заданное количество пикселей. Эта команда проскроллит страницу на 100 пикселей вниз:
browser.execute_script("window.scrollBy(0, 100);")

Загрузка файлов--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Загрузку файлов на сайт можно реализовать через .send_keys(), но передать не текст, а путь к файлу в качестве аргумента.
Для написания пути, универсального для ос, можно использовать модуль oc:
import os 

current_dir = os.path.abspath(os.path.dirname(__file__))    # получаем путь к директории текущего исполняемого файла вместо пути к самому файлу
file_path = os.path.join(current_dir, 'file.txt')           # добавляем к этому пути имя файла 
element.send_keys(file_path)

Работа с окнами--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Простейший пример окна - всплывающий alert (просто сообщение с кнопкой ок). Это модальное окно, то есть, пока оно открыто, остальной интерфейс заблокирован.

Для его закрытия нужно переключиться на окно алерта и принять его:
alert = browser.switch_to.alert
alert.accept()

.text возвращает содержимое сообщения:
alert_text = alert.text

Другой пример модального окна - confirm. В данном случае можно не только принять, но и отклонить confirm. Переключаемся мы на него такой же командой, как и на алерт:
confirm = browser.switch_to.alert
confirm.accept()
confirm.dismiss()

Третий вид модального окна - prompt. Там добавляется поле для ввода, заполняется через .send_keys():
prompt = browser.switch_to.alert
prompt.send_keys('Answer')
prompt.accept()

Переход на новую вкладку браузера--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
WebDriver может работать только с одной вкладкой сразу, поэтому на открытые новые вкладки надо переключаться явно:
browser.switch_to.window(window_name)

Чтобы узнать имя новой вкладки, нужно использовать метод window_handles, который возвращает массив имён всех вкладок. Зная, что в браузере теперь открыто две вкладки, выбираем вторую вкладку:
new_window = browser.window_handles[1]

Также мы можем запомнить имя текущей вкладки, чтобы иметь возможность потом к ней вернуться:
first_window = browser.window_handles[0]

Настройка ожиданий-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
В современных сайтах используется подход Single-Page Application (или подход одностраничных приложений). Содержимое страницы при этом динамически обновляется с помощью JavaScript,
который незаметно обменивается с сервером информацией, например, посредством REST API.

В целом все довольны. Разве что создателям автотестов на интерфейсы приходится туго. Неожиданно появляющиеся или пропадающие элементы на странице, непредсказуемое время полной отрисовки страницы,
изменяющийся текст в кнопках или в сообщениях веб-сайта — эти особенности работы SPA-приложений приходится учитывать в автотестах, и, стоит признать, это является одним из самых сложных и головоломных
аспектов разработки автотестов на Selenium (да и в других фреймворках для написания end-to-end тестов тоже).

Если кнопка появляется с анимацией в секунду, то за эту секунду тест успеет бросить исключение NoSuchElement (был пример в задании 2.4).

Можно добавить таймер. Но что если элемент с сообщением тоже будет появляться с задержкой? Добавить еще один time.sleep() перед поиском сообщения? А если изменится время задержки при появлении кнопки? Увеличим 
длительность паузы? А еще на разных машинах с разной скоростью интернета кнопка может появляться через разные промежутки времени. Можно перед каждым действием добавить задержку, но тогда значительную часть времени
прогона тестов будут занимать бесполезные ожидания, при этом с увеличением количества тестов эта проблема будет только расти.

В противовес негибкому time.sleep() есть решение - selenium implicit waits (неявное ожидание).
Механизм таков, что, подключив этот метод и задав в нем верхнее значение ожидания (например, 5 секунд), мы заставляем драйвер при ненахождении элемента ожидать его, но
каждые 0.5 секунд он будет проверять доступность. Таким образом, если задержка появляения элемента была низкой, то код будет исполняться практически мгновенно.
Такой паттерн ожидания будет применен ко всем будущим командам.

from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
# говорим WebDriver искать каждый элемент в течение 5 секунд
browser.implicitly_wait(5)

browser.get("http://suninjuly.github.io/wait1.html")

WebDriver может бросить три вида исключения при попытке взаимодействия с элементом:
NoSuchElementException - если за все 5 секунд ожидания так и не было найдено элемента в DOM (Document Object Model).
StaleElementReferenceException - если элемент был найден, но к моменту клика уже пропал (stale - устарел), такое может произойти при деактивации или скрытии кнопки скриптом.
ElementNotVisibleException - если элемент был найден, но невидим (имеет нулевой размер), и пользователь не смог бы с ним взаимодействовать.

Однако, таким образом мы решили только проблему ожидания элементов, в то время как у элементов могут быть разные свойства, которые важны для тестов, но не проверяются через find_element.
Например, кнопка неактивна, содержит текст, который меняется после нажатия, перекрыта другим элементом или невидима. В таком случае нажатие будет проэмулировано, но резульата не будет.

Для надежности теста надо дождаться не только появления кнопки, но и становления ее кликабельной.
Реализуется это через явные ожидания (explicit waits), которые позволяют задать специальное ожидание для конкретного элемента.
Задание явных ожиданий реализуется с помощью инструментов WebDriverWait и expected_conditions.

from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium import webdriver

browser = webdriver.Chrome()

browser.get("http://suninjuly.github.io/wait2.html")

# говорим Selenium проверять в течение 5 секунд, пока кнопка не станет кликабельной (в метод element_to_be... передается кортеж)
button = WebDriverWait(browser, 5).until(
        EC.element_to_be_clickable((By.ID, "verify"))
    )
button.click()
message = browser.find_element(By.ID, "verify_message")

assert "successful" in message.text

element_to_be_clickable возвращает элемент, либо False.
Правило ожидания передается в метод .until(), в модуле EC есть множество правил.
Также есть вариант метода .until_not() для негативации условия (например, чтобы проверить, что кнопка после нажатия стала неактивной).

Тестирование web-приложений--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Сравнение ручного и автоматизированного тестирования:
Шаги для ручного теста могут быть весьма абстрактными (например, зарегестрировать пользователя, без указания способа), поэтому возможно найти новые проблемы, в то время как в автотестах строгий порядок шагов
и их детализация.
Из-за абстрактности описания шагов ручные тесты иногда могут приводить к ложноположительным результатам, когда ожидаемый результат достигнут, но сценарий выполнен не так, как задумывалось, и был пропущен баг.
В то же время, автотесты всегда проходят по одному сценарию.
В ручных тестах требуется много времени для проверки, что ведет к усталости тестировщика и к ошибкам, а автотесты можно запускать хоть на каждый коммит.

Однако, и у автоматизированных тестов есть минусы:
Возможная нестабильность теста, которая связана не с его качеством, а с внешними проблемами (нестабильное сетевое соединение, проблемы с серверами, обновление кода продукта в момент запуска тестов).
Требуется достаточно много времени на разработку и поддержку набора автотестов.

Но в среднем выгоднее делать автоматическое тестирование, так как это быстрее, и баги находятся на ранних этапах разработки, не нужно откладывать релиз ради их решения, и новые фичи выходят быстрее, что выгодно.

Юнит тесты и интеграционные тесты:
Юнит-тесты проверяют очень маленький кусок кода, обычно конкретную функцию, и чаще всего их пишут разработчики, которые хорошо понимают возможные крайние случаи для своего стека технологий.
Интеграционные тесты проверяют взаимодействие сразу нескольких систем. Они могут создаваться и поддерживаться как разработчиками и тестировщиками, так и аналитиками (если для них разработан удобный фреймворк
для написания тестов).

Юнит-тесты всегда автоматизированы, так как проверяют непосредственно работу кода. Интеграционные тесты могут быть ручными и автоматизированными.
Иногда выделяют отдельную категорию end-to-end (е2е) тестов, которые проверяют полный стек технологий приложения и пользовательский сценарий взаимодействия с приложением как с черным ящиком.
UI-тесты, которые разрабатываются с помощью Selenium, стоит отнести к разряду end-to-end тестов, так как они проверяют совместную работу всех систем web-продукта: работу frontend и backend, работу базы данных,
дополнительные сервисы, такие как аналитика, платежные системы и так далее.

Пирамида тестов:
Это примерная концепция, которая показывает, сколько тестов какого вида должно быть, и насколько они комплексны.
Основание пирамиды - Unix тесты, которые пмаленькие и проверяют отдельные фичи. Они простые и их много.
Второй слой - интеграционные (сервисные, куча названий) тесты. Их должно быть меньше, они работают с рядом фич одновременно, поэтому сложнее и дольше работают/пишутся.
Третий слой (иногда вершина) - e2e (end to end, также UI тесты) тесты. Из конца в конец, то есть, это самые большие тесты, проверяющие работу от начала до конца. Их должно быть совсем мало.
Если располагать ручные тесты в пирамиде, то они будут выше e2e, поскольку их должно быть еще меньше, и они еще медленнее.

Структура любого теста:
Входные данные.
Тестовый сценарий, то есть набор шагов, которые надо выполнить для получения результата.
Проверка ожидаемого результата.

Проверка ожидаемого результата:
В python есть встроенная инструкция assert, которая проверяет истинность утверждений. Если он возвращает ложь, бросается исключение с указанием строки.
Когда тестов становится много, сложно вспомнить, что именно проверяется, поэтому можно написать дополнительное сообщение при написании assert через запятую после логического выражения:

>>> assert abs(-42) == -42, "Should be absolute value of a number"
Traceback (most recent call last):

  File "<stdin>", line 1, in <module>

AssertionError: Should be absolute value of a number

Сообщения об ошибках:
Хорошие сообщения в assert могут сохранить часы времениЮ особенно, когда количество тестов уже перевалило за сотню.
Если проверяется наличие элемента, то обязательно пишется, что это за элемент по смыслу на странице.
assert self.is_element_present('create_class_button', timeout=30), "No create class button"
Если элемент встречается на нескольких страницах приложения, не лишним будет указать, где именно произошла ошибка:
assert self.is_element_present('new_announcement_button', timeout=30), "No new announcement button on profile page"
Если проверяется какой-то текст (сообщение, url), то лучше указать два значения - ожидаемое и фактическое.

Способы сделать составное сообщение:
1. Конкатенация строк (не самый читабельный вариант):
actual_result = "abrakadabra"
print("Wrong text, got " + actual_result + ", something wrong")
2. Использование .format():
"Let's count together: {}, then goes {}, and then {}".format("one", "two", "three")
Let's count together: one, then goes two, and then three - вывод.
3. Использование f-string (примерно то же самое, но новее и позволяет четко указывать в фигурных скобках, что там за переменная, либо код (2+3), вместо того, чтоб считать, плюс простая инициализация через f''):
str1 = "one"
str2 = "two"
str3 = "three"
print(f"Let's count together: {str1}, then goes {str2}, and then {str3}")

Любой текст и контент на странице лучше записывать в отдельную переменную, чтоб он не изменился, и мы получили актуальное сообщение об ошибке:
catalog_text = self.catalog_link.text # считываем текст и записываем его в переменную
assert catalog_text == "Каталог", \
    f"Wrong language, got {catalog_text} instead of 'Каталог'"

Тестовые сценарии:
Созданные тесты нужно хранить в отдельном файле, чтобы их было удобно запускать и хранить в гите. Отдельные тесты можно оформлять в виде отдельных функций.
Хорошей идеей будет использование конструкции if __name__ == "__main__", которая будет исполнять код внутри только в случае, если пользователь напрямую открыл файл, а не подключил его в качестве модуля.

def test_abs1():
    assert abs(-42) == 42, "Should be absolute value of a number"

def test_abs2():
    assert abs(-42) == -42, "Should be absolute value of a number"

if __name__ == "__main__":
    test_abs1()
    test_abs2()
    print("Everything passed")

Минусы такого подхода:
Когда тестов становится много, становится сложно запускать только те наборы тестов, которые нужны прямо сейчас.
Для каждого теста нужно создавать тестовые данные и окружение отдельно. Например, если мы захотим для каждого теста запускать браузер, а после завершения теста браузер закрывать, то логику работы с браузером
придется дублировать в коде каждого теста.
Если один из тестов завершится с ошибкой, например, тест упадёт с ошибкой AssertionError, то последующие тесты не запустятся. Мы не узнаем, были ли проблемы в этих тестах, пока не починим упавший тест или
пока не запустим эти тесты по отдельности.

Для решения этих проблем и упрощения написания и запуска тестов существуют специальные фреймворки, которые называются test runners (тест-раннеры).
Три основных тестовых фреймворка для Python - unittest, PyTest и nose.
Модуль unittest является встроенным инструментом Python — и это его большой плюс. PyTest и nose устанавливаются дополнительно, они позволяют получить расширенные возможности по сравнению с unittest.
PyTest позволяет писать более простой код и гибко настраивать запуск тестов. Для него написано множество плагинов, которые позволяют решить практически любую проблему, связанную с автотестами.

Модуль unittest--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Все тесты-раннеры самостоятельно находят тестовые методы при запуске файла, однако, для этого необходимо следовать общепринятым правилам.
Например, все тестовые методы должны называться, начиная с test_. Дальше идет любой текст, который является уникальным названием для теста.
У unittest есть сои дополнительные правила:
Тесты должны находиться в специальном тестовом классе.
Вместо assert должны использоваться специальные assertion методы.
Для написания теста из прошлого примера необходимо:
1. Импортировать модуль unittest
2. Создать класс, который будет наследоваться от класса TestCase
3. Сделать тестовые функции методами нового класса, добавив self в качестве аргумента.
4. Поменять assert на self.assertEqual() (в данном случае, для замены логического выражения на основе равенства)
5. Заменить строку запуска программы на unittest.main()

import unittest

class TestAbs(unittest.TestCase):
    def test_abs1(self):
        self.assertEqual(abs(-42), 42, "Should be absolute value of a number")
        
    def test_abs2(self):
        self.assertEqual(abs(-42), -42, "Should be absolute value of a number")
        
if __name__ == "__main__":
    unittest.main()

Тестирование с помощью PyTest------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Так как модуль - скорее, отдельная программа, чем библиотека, импортировать в файлы его не нужно. Запуск вызывается из консоли.
Преимущества:
1. PyTest полностью обратно совместим с фреймворками unittest и nosetest. Это означает, что если изначально вы писали тесты, используя unittest, то перейти на PyTest можно буквально в ту же минуту(запустить тест
можно в консоли командой pytest путь\к\файлу.py).
2. Подробный отчёт с поддержкой цветовых схем из коробки.
3. PyTest не требует написания дополнительных специфических конструкций в тестах, как того требует unittest (no boilerplate).
4. Для проверок используется стандартный assert из Python.
5. Возможность создания динамических фикстур (специальных функций, которые настраивают тестовые окружения и готовят тестовые данные).
6. Дополнительные возможности по настройке фикстур.
7. Параметризация тестов — для одного теста можно задать разные параметры (тест запустится несколько раз с разными тестовыми данными).
8. Наличие маркировок (marks), которые позволяют маркировать тесты для их выборочного запуска.
9. Возможность передавать дополнительные параметры через командную строку для настройки тестовых окружений.
10. Большое количество плагинов, которые расширяют возможности PyTest и позволяют решать узкоспециализированные проблемы, что может сэкономить много времени.

Недостатки:
1. PyTest требуется устанавливать дополнительно, так как он не входит в стандартный пакет библиотек Python, в отличие от unittest. Нужно не забывать об этом, когда вы будете настраивать автоматический запуск
тестов с помощью CI-сервера.
2. Использование PyTest требует более глубокого понимания языка Python, чтобы разобраться, как применять фикстуры, параметризацию и другие возможности PyTest.

Создание профиля пакетов-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Команда pip freeze > requirements.txt позволяет записать модули с их версиями во внешний файл, и затем установить, например, на новое вирутальное окружение, чтоб у разных людей всегда было одинаковое ПО.
Команда установки из txt:
pip install -r requirements.txt

Продолжение тестирования с PyTest--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Правила запуска тестов:
Если не передать никакого аргумента при запуске pytest, то он будет искать тесты в текущей директории.
В качестве аргумента можно передать как файл, так и путь к директории, или же комбинацию из директории и файлов:
pytest scripts/selenium_scripts
# найти все тесты в директории scripts/selenium_scripts

pytest test_user_interface.py
# найти и выполнить все тесты в файле 

pytest scripts/drafts.py::test_register_new_user_parametrized
# найти тест с именем test_register_new_user_parametrized в указанном файле в указанной директории и выполнить

Поиск рекурсивен, то есть, обходятся все вложенные в указанной директории.

В процессе поиска ищутся файлы, начинающиеся на test_, или заканчивающиеся на _test, имеющие расширение .py
Внутри найденных файлов ищутся либо функции вне классов, которые начинаются на test_, либо такие же функции в классах, название которых начинается с Test(и без метода __init__ внутри класса).

При передаче дополнительного флага -v (verbose, подробный) в pytest в отчёт добавится дополнительная информация со списком тестов и статусом их прохождения.
Флаг --tb='line' сокращает вывод, оставляя только нужную информацию.

Несмотря на то, что PyTest принимает тесты, написанные в unittest стиле, целесообразно при его подключении писать более простые конструкции, которые он также поддерживает:
def test_abs1():
    assert abs(-42) == 42, "Should be absolute value of a number"

def test_abs2():
    assert abs(-42) == -42, "Should be absolute value of a number"

Файл надо назвать так, чтобы в начале или конце было слово test с нижним подчеркиванием, и все готово, тест будет определяться.

Обычный assert в pytest гораздо удобнее, чем методы assertion unittest.

Также мы можем проверить, бросается ли исключение, хотя это и редко где используют,при помощи метода .raises():
from selenium.common.exceptions import NoSuchElementException

def test_exception1():
    try:
        browser = webdriver.Chrome()
        browser.get("http://selenium1py.pythonanywhere.com/")
        with pytest.raises(NoSuchElementException):
            browser.find_element(By.CSS_SELECTOR, "button.btn")
            pytest.fail("Не должно быть кнопки Отправить")
    finally: 
        browser.quit()

Тест упадет, так ак не будет брошено исключения, которое ожидалось.
pytest.fail('') хранит сообщение, которое выводится при ошибке (assert способ также работает).

Использование фикстур в PyTest-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Фикстуры в контексте PyTest — это вспомогательные функции для наших тестов, которые не являются частью тестового сценария.
Назначение фикстур может быть самым разным. Одно из распространенных применений фикстур — это подготовка тестового окружения и очистка тестового окружения и данных после завершения теста (исполнение команд до
запуска тестового метода, и после).
Фикстуры можно использовать для самых разных целей: для подключения к базе данных, с которой работают тесты, создания тестовых файлов или подготовки данных в текущем окружении с помощью API-методов.

Создание setup_ и teardown_ методов - классическое использование фикстур. setup_class() будет исполняться автоматически в начале работы с классом, а teardown_class() запустится сам в конце.
Если использовать не setup_class и teardown_class, а setup_method и teardown_method, то они будут выполняться при вызове каждого прочего метода (то есть, теста), и после вызова соответственно.

В setup можно вынести открытие браузера, а в teardown его закрытие, чтоб не писать это для каждого теста вручную.

Тесты мы будем объединять в тест-сьюты (тестовые классы).

Следующий код будет открывать браузер в самом начале работы с тест-сьютом, и закрывать его в самом конце.

from selenium import webdriver
from selenium.webdriver.common.by import By
link = "http://selenium1py.pythonanywhere.com/"


class TestMainPage1():

    @classmethod
    def setup_class(self):
        print("\nstart browser for test suite..")
        self.browser = webdriver.Chrome()

    @classmethod
    def teardown_class(self):
        print("quit browser for test suite..")
        self.browser.quit()

    def test_guest_should_see_login_link(self):
        self.browser.get(link)
        self.browser.find_element(By.CSS_SELECTOR, "#login_link")

    def test_guest_should_see_basket_link_on_the_main_page(self):
        self.browser.get(link)
        self.browser.find_element(By.CSS_SELECTOR, ".basket-mini .btn-group > a")

Это не очень оптимально, потому что прошлые тесты могут через кэш повлиять на следующие, либо вообще крашнуть браузер.
Тут также использовался декоратор.

Поэтому лучше открывать по браузеру для каждого теста:

class TestMainPage2():

    def setup_method(self):
        print("start browser for test..")
        self.browser = webdriver.Chrome()

    def teardown_method(self):
        print("quit browser for test..")
        self.browser.quit()

    def test_guest_should_see_login_link(self):
        self.browser.get(link)
        self.browser.find_element(By.CSS_SELECTOR, "#login_link")

    def test_guest_should_see_basket_link_on_the_main_page(self):
        self.browser.get(link)
        self.browser.find_element(By.CSS_SELECTOR, ".basket-mini .btn-group > a")

Среди минусов способа - более долгая работа тестов.

Фикстуры, возвращающие значение----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Это был базовый подход к созданию фикстур.
PyTest предлагает дополнительные инструменты для работы с фикстурами.

Сейчас мы создадим фикстуру browser, которая будет создавать объект WebDriver.
Для этого напишем метод browser и укажем, что он является фикстурой, с помощью декоратора @pytest.fixture
После этого мы сможем передавать фикстуру как параметр тестов, чтобы там вызывать ее.

import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By

link = "http://selenium1py.pythonanywhere.com/"


@pytest.fixture
def browser():
    print("\nstart browser for test..")
    browser = webdriver.Chrome()
    return browser


class TestMainPage1():
    # вызываем фикстуру в тесте, передав ее как параметр
    def test_guest_should_see_login_link(self, browser):
        browser.get(link)
        browser.find_element(By.CSS_SELECTOR, "#login_link")

    def test_guest_should_see_basket_link_on_the_main_page(self, browser):
        browser.get(link)
        browser.find_element(By.CSS_SELECTOR, ".basket-mini .btn-group > a")

Запуск pytest с флагом -s покажет принты.

В данном случае у нас открывались браузеры, но не закрывались, и закрылись лишь после окончания тестов, благодаря сборщику мусора pytest.
Но, чтобы память не кончилась, нужно явно закрывать окна.
Мы будем использовать для этого финализатор.
Один из вариантов - использование yield.
После завершения теста, который вызывал фикстуру, выполнение фикстуры продолжится со строки, следующей за строкой со словом yield:

import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By

link = "http://selenium1py.pythonanywhere.com/"


@pytest.fixture
def browser():
    print("\nstart browser for test..")
    browser = webdriver.Chrome()
    yield browser
    # этот код выполнится после завершения теста
    print("\nquit browser..")
    browser.quit()


class TestMainPage1():
    # вызываем фикстуру в тесте, передав ее как параметр
    def test_guest_should_see_login_link(self, browser):
        browser.get(link)
        browser.find_element(By.CSS_SELECTOR, "#login_link")

    def test_guest_should_see_basket_link_on_the_main_page(self, browser):
        browser.get(link)
        browser.find_element(By.CSS_SELECTOR, ".basket-mini .btn-group > a")

Видимо, декоратор включает в себя next() или for, чтобы работа кода после yield продолжилась.
Финализатор выполнится, даже если тест упал с ошибкой.

Есть также способ через встроенную фикстуру request и ее метода addfinalizer, но это не разбиралось, можно прочесть в документации (https://docs.pytest.org/en/latest/how-to/fixtures.html#adding-finalizers-directly).

Область видимости (scope)----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Для фикстур можно задавать область покрытия фикстур. Допустимые значения: “function”, “class”, “module”, “session”.
Соответственно, фикстура будет вызываться один раз для тестового метода, один раз для класса, один раз для модуля(файл с тестами) или один раз для всех тестов, запущенных в данной сессии (все файлы с тестами).
Задается он так:
@pytest.fixture(scope="class")

Автоиспользование фикстур----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
При описании фикстуры можно указать дополнительный параметр autouse=True, который укажет, что фикстуру нужно запустить для каждого теста даже без явного вызова:
@pytest.fixture(autouse=True)
С таким параметром фикстура выполнится для каждого теста без передачи параметров, вызова, или чего либо.
Нужно быть аккуратнее с этим параметром, потому что фикстура выполняется для всех тестов. Без явной необходимости автоиспользованием фикстур лучше не пользоваться.

Маркировка тестов в PyTest---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Когда тестов становится много, практично их разметить по категориям (вроде критичные /smoke/, для прогона после каждого коммита, некритичные /regression/, для прогона перед релизом, и т.д.).
С помощью меток marks мы можем помечать тесты, и делать выборочный запуск.
Для маркировки теста нужно написать над ним декоратор вида @pytest.mark.mark_name, где mark_name — произвольная строка:
class TestMainPage1():

    @pytest.mark.smoke
    def test_guest_should_see_login_link(self, browser):
        browser.get(link)
        browser.find_element(By.CSS_SELECTOR, "#login_link")

    @pytest.mark.regression
    def test_guest_should_see_basket_link_on_the_main_page(self, browser):
        browser.get(link)
        browser.find_element(By.CSS_SELECTOR, ".basket-mini .btn-group > a")

Для выборочного запуска тестов с определенной маркировкой нужно добавить при запуске флаг -m + имя метки:
pytest -s -v -m smoke test_fixture8.py

При этом появится предупреждение о использовании незарегистрированных меток. Это необходимо для того, чтобы избежать опечаток.

Для регистрации метки надо создать файл pytest.ini в той директории, где лежит файл с тестами и прописать там следующее:
[pytest]
markers =
    smoke: marker for smoke tests
    regression: marker for regression tests
Описание меток необязательно.
После этого предупреждения не будет, пока не будет сделана какая-то ошибка.

Маркировать можно не только отдельные тесты, но и тестовый класс, тогда метка будет применена ко всем тестам в тест-сьюте.

