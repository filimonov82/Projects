Selenium — это open-source проект, который предназначен главным образом для автоматизации тестирования веб-приложений.
Проект состоит из множества компонентов, как Selenium IDE, Grid, Server, WebDriver и т.д.

В данном курсе мы будем работать с Selenium WebDriver - интерфейсом взаимодействия клиентского кода (тестов) с браузером (через драйверы).
Данный инструмент позволяет писать тесты на любом ЯП (наиболее популярны для него Java и Python) под любой браузер при помощи драйвера, который разрабатывают под selenium 
разработчики браузера.

В итоге, написанные тесты, по большей части, универсальны, и подходят для любого браузера.
Таким образом, WebDriver признали стандартом протокола взаимодействия с браузером.

Для выполнения определенных действий на веб странице необходимо понимать ее структуру.
Элементы внутри страницы можно найти несколькими способами:
1. Поиск с помощью CSS-селекторов, когда путь к элементу описывается через синтаксис CSS. Селектор — это описание пути к элементу на странице.
2. Поиск с помощью указания значений тегов или атрибутов элементов: ID, class, и т.д.
3. Поиск с помощью языка запросов XPath.

Поиск с помощью css селекторов покрывает практически все возможные ситуации, и выглядит достаточно читабельным, поэтому он нас интересует в первую очередь.
Однако не редки случаи, когда другие способы в приоритете (css не умеет искать вверх, поэтому не подходит для поиска предков).

css селектор:
button {
  color:green;
}

html тэг:
<p>Текст</p>

Атрибуты тэгов:
Атрибут class - <div class="simple-text main">Здесь написан текст.</div>
У данного элемента имеется два класса, simple-text и main. Классы обычно используются для использования в css.

Атрибут name - <a name="top"></a>
Данный атрибут можно использовать в качестве якоря (закладки для перехода к нему через href="#top"), а также для поиска элемента.

Атрибут id - <button id="save_button">Сохранить</button>
Это уникальный указатель на элемент, в пределах страницы id не должны повторяться.

!Важно. В современных JavaScript-фреймворках id-атрибуты чаще всего генерируются динамически самим фреймворком, поэтому
они изменяются каждый раз при перезагрузке страницы и совершенно нечитабельны, например: вы увидите что-то вроде
id="u_ps_0_0_n" или id="avadspffd". В таких случаях вам придется пользоваться другими селекторами или использовать собственные
data-атрибуты, о которых мы расскажем далее. Названия классов также могут генерироваться автоматически. Поэтому предлагаем
вам простое правило: если увидите нечеловекочитаемое значение атрибута или если значение атрибута меняется при перезагрузке
страницы, то не используйте его.

data-атрибуты:
Это специальные атрибуты для тестов, которые не изменяются, как правило, начинаются с data-, и которые разработчик по договоренности может добавить.

Поиск элементов с помощью CSS селекторов.-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Части html страницы, по которым можно найти элемент:
id, tag, name, class, значение атрибута.

Поиск по id - если у элемента есть id, например, id="bullet", то для его поиска есть селектор #bullet, который можно ввести в поиске панели элемента (ctrl f), или в коде.

Поиск по tag - для такого поиска вводим сам тэг, например, h1, но это не очень удобно, так как обычно на странице множество одинаковых тэгов.

Поиск по значению атрибута - указываем атрибут и его значение в [] - [id="bullet"].

Поиск по name - это разновидность поиска по значению атрибута, и записывается также, но, естественноЮ атрибут тут name. Это довольно частый вид поиска, и в WebDriver выдеояется в отдельный вид.

Поиск по class - тоже разновидность поиска по значению атрибута и может записываться в [], но в таком случае, если у атрибута несколько классов, то надо писать их все в точном порядке,
иначе элемент не будет найден. Но мы можем писать упрощенно, так как это очень частоиспользуемый атрибут в css, написав значение атрибута и предварив его точкой .value
В таком виде ищется просто вхождение, поэтому можно указать только один из классов, или все в любом порядке вот так: .value1.value2
Однако стоит помнить, что такой поиск чувствителен к регистру, и .Value это уже другой класс.

Поиск с помощью составных CSS селекторов.-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<div id="posts" class="post-list">
  <div id="post1" class="item">
    <div class="title">Как я провел лето</div>
    <img src="./images/summer.png">
  </div>
  <div id="post2" class="item">
    <div class="title second">Ходили купаться</div>
    <img src="./images/bad_dog.jpg">
  </div>
  <div id="post3" class="item">
    <div class="title">С друзьями</div>
    <img src="./images/friends.jpg">
  </div>
</div>

Если бы мы хотели найти здесь элемент с текстов Ходили купаться, мы могли бы воспользоваться составным селектором, то есть, селектором с разными атрибутами.
#post2 .title - такой селектор нам подходит. Он значит, что мы ищем элемент с id post2, пробел значит, что следуюший селектор - потомок первого, 
и ищется класс title во всех детях этого элемента.
Если же мы не поставим пробела, то ничего не найдется, потому что будет искаться элемент и с таким id, и с таким классом, а таких нет.

Другой способ - #post2 > div.title - здесь мы указали еще тег элемента div и уточнили, что нужно взять элемент с тегом и классом: div.title,
который находится строго на один уровень иерархии ниже чем элемент #post2. Для этого используется символ > (символ > может обособляться пробелами, а может нет, это не учитывается).

Еще один способ найти этот элемент - #posts > .item:nth-child(2) > .title - Псевдо-класс :nth-child(2) — позволяет найти второй по порядку элемент среди дочерних элементов для #posts.
Затем с помощью конструкции > .title мы указываем, что нам нужен элемент .title, родителем которого является найденный ранее элемент .item.

Поиск элементов с помощью XPath---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Если разработчик не идет на встречу с добавлением data атрибутов, приходится выкручиваться самому.
XPath (XML Path Language) это язык запросов, который использует древовидную структуру документа, то есть, все работает через /.
/ в данном случае обращается к прямому потомку (как >), а // - ко всем потомкам (как пробел).
Корневой элемент всегда <html>, /html/body/header - пример использования.
//div найдет все тэги div.

Символ [] — это команда фильтрации. Если найдено много результатов, используем это.
Поиск по атрибуту - //img[@id='bullet'] (@ в данном случае обпределяет id как атрибут, атрибут может быть любым).
По порядковому номеру - //div[@class="row"]/div[2] - находим div элемент с классом row, и обращаемся к его второму дочернему элементу (как :nth-child(2)).
По полному совпадению внутреннего текста (только XPath так может) - //p[text()="Lenin cat"] - но это не всегда хорошая практика, особенно на мультиязычных сайтах, поскольку надо точное совпадение.
По частичному совпадению текста или атрибута при помощи функции contains() - //p[contains(text(), "cat")] - ищется текст, содержащий слово cat.
Также это можно использовать для частичного совпадения атрибутов, например, классов, когда их много - //div[contains(@class, "navbar")].
Можно также использовать булевы операции and, or, not и арифметические операции - //img[@name='bullet-cat' and @data-type='animal'].

Знак * - выбор всех элементов - //div/*[@class="jumbotron-heading"].
Поиск через XPath также регистрозависим.

Поиск элементов с помощью selenium------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Для поиска используется метод find_element, который принимает два аргумента - тип локатора и его значение.
Для его использования надо импортировать компонент webdriver из selenium и класс by, чтобы подключить все типы локаторов.
Под локатором понимается стратегия поиска (какой вид поиска).

from selenium import webdriver
from selenium.webdriver.common.by import By

Способы поиска:
find_element(By.ID, value) - поиск по атрибуту id. Если разработчики проставляют всем элементам в приложении уникальный id, то это наиболее удобный и стабильный метод.
find_element(By.CSS_SELECTOR, value) - поиск с помощью правил на основе CSS. Этот способ можно считать универсальным методом поиска, поскольку почти все сайты используют в своей структуре CSS для верстки.
Это наиболее вероятный способ для поиска после id.
find_element(By.XPATH, value) - поиск через XPath.
find_element(By.NAME, value) - поиск по атрибуту name.
find_element(By.TAG-NAME, value) - поиск по тэгу.
find_element(By.CLASS_NAME, value) - поиск по классу.
find_element(By.LINK_TEXT, value) - поиск ссылки на странице по полному совпадению.
find_element(By.PARTIAL_LINK_TEXT, value) - поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки.

Пример поиска по id элемента:

from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/simple_form_find_task.html")
button = browser.find_element(By.ID, "submit_button")

В случае, если условиям поиска будет соответствовать несколько элементов на странице, данный метод вернет только первое вхождение.
Чтобы избежать подобной проблемы, нужно либо написать более подробный селектор, либо использовать метод find_elements (во множественном числе). Данный метод будет рассмотрен позже.

Работа с браузером в Selenium---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Браузер не всегда закрывается автоматически после эмуляции, поэтому его надо закрывать явно через метод browser.quit()
Каждый раз при создании браузера через метод webdriver.Chrome() создается отдельный процесс, который останется висеть в системе, если закрыть окно бразуера вручную.
Таким образом, для того, чтобы не исчерпать всю ОЗУ, надо закрывать процессы вручную.

from selenium import webdriver
from selenium.webdriver.common.by import By


link = "http://suninjuly.github.io/simple_form_find_task.html"
browser = webdriver.Chrome()
browser.get(link)
button = browser.find_element(By.ID, "submit_button")
button.click()

# закрываем браузер после всех манипуляций
browser.quit()

Помимо метода .quit() существует также метод .close(), но он закрывает только текущее активное окно, в то время как .quit() останавливает все процессы webdriverа.

Может случиться так, что код не дойдет до конца, где вызывается данный метод, упав по пути с исключением.
На такой случай можно воспользоваться конструкцией try/finally.

from selenium import webdriver
from selenium.webdriver.common.by import By

link = "http://suninjuly.github.io/simple_form_find_task.html"

try:
    browser = webdriver.Chrome()
    browser.get(link)
    button = browser.find_element(By.ID, "submit_button")
    button.click()

finally:
    # закрываем браузер после всех манипуляций
    browser.quit()

Даже если код в блоке try бросит исключение, код в блоке finally выполнится. Подробнее об обработке исключений будет в будущих уроках, в том числе с использованием более лаконичных конструкций.

Также хорошей практикой считается добавление пустой строки в конце скрипта, так как системы UNIX/Linux их ожидают, и в случае отсутствия последняя строка с кодом может не выполниться.

Пример поиска по тексту ссылки:
link = browser.find_element(By.LINK_TEXT, "Degree Symbol in Math")
link.click()

Пример поиска по части текста ссылки:
link = browser.find_element(By.PARTIAL_LINK_TEXT, "Math")
link.click()

Такой поиск, обычно, более гибок, однако, используя его, нужно быть осторожным, поскольку можно легко выйти не на тот элемент.

Поиск множества одинаковых элементов-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Метод .find_elements возвращает список из всех найденных элементов, если элементы не найдены, возвращается пустой список (в то время как find_element бросает исключение).

# подготовка для теста
# открываем страницу первого товара
# данный сайт не существует, этот код приведен только для примера
browser.get("https://fake-shop.com/book1.html")

# добавляем товар в корзину
add_button = browser.find_element(By.CSS_SELECTOR, ".add")
add_button.click()

# открываем страницу второго товара
browser.get("https://fake-shop.com/book2.html")

# добавляем товар в корзину
add_button = browser.find_element(By.CSS_SELECTOR, ".add")
add_button.click()

# тестовый сценарий
# открываем корзину
browser.get("https://fake-shop.com/basket.html")

# ищем все добавленные товары
goods = browser.find_elements(By.CSS_SELECTOR, ".good")

# проверяем, что количество товаров равно 2
assert len(goods) == 2

Уникальность селекторов-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Идеальный селектор - тот, что позволяет найти только один искомый элемент.
Уникальные селекторы делают тесты стабильными и менее зависимыми от верстки.

Хороший тест - тот, что проверяет атомарную часть функциональности, а не все и сразу. Благодаря таким тестам мы быстрее локализуем баг, в то время как большой тест при падении
укажет только на первую ошибку.

Рассмотрим следующий пример: у нас есть форма регистрации, в которой есть обязательные и необязательные поля для заполнения. Нужно проверить, что можно успешно зарегистрироваться на сайте.

Сценарий плохого автотеста:

1

Открыть страницу с формой
Заполнить все поля
Нажать кнопку "Регистрация"
Проверить, что есть сообщение об успешной регистрации
Лучше разбить предыдущий тест на набор более простых автотестов:

1

Открыть страницу с формой
Заполнить только обязательные поля
Нажать кнопку "Регистрация"
Проверить, что есть сообщение об успешной регистрации
2

Открыть страницу с формой
Заполнить все обязательные поля
Заполнить все необязательные поля
Нажать кнопку "Регистрация"
Проверить, что есть сообщение об успешной регистрации
3

Открыть страницу с формой
Заполнить только необязательные поля
Проверить, что кнопка "Регистрация" неактивна

Assert в наших тестах ищет баги, если он бросает исключение, то найден баг, а если нет, то все в порядке.

Для того, чтоб следующая страница успевала загрузиться, мы ставим time.sleep(), однако это считается плохой практикой, поскольку неизвестно, сколько нужно ждать, в будущем
будут показаны более подходящие конструкции, а пока пользуемся этим.

Работа с элементами типа checkbox и radiobutton------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Checkbox (чекбокс или флажок) и radiobutton (радиобаттон или переключатель) — часто используемые в формах элементы.
Основная разница между ними состоит в том, что флажки позволяют выбирать/отключать любой из представленных вариантов, а
переключатели позволяют выбрать только один из вариантов. Далее мы будем называть эти элементы на англоязычный манер: checkbox и radiobutton.

Оба этих элемента создаются при помощи тега input со значением атрибута type равным checkbox или radio соответственно:
<input type="checkbox">
<input type="radio">

Если checkbox или radiobutton выбран, то у элемента появится новый атрибут checked без значения. Часто атрибут checked уже установлен для одного из элементов по умолчанию:
<input type="checkbox" checked>
<input type="radio" checked>

Radiobuttons объединяются в группу, где все элементы имеют одинаковые значения атрибута name, но разные значения атрибута value:
<input type="radio" name="language" value="python" checked>
<input type="radio" name="language" value="selenium">

Checkboxes могут иметь как одинаковые, так и разные значения атрибута name. Поэтому и те, и другие лучше искать с помощью значения id или значения атрибута value.

Выбираются такие элементы через .click()

Также вы можете увидеть тег label рядом с input. Этот тег используется, чтобы сделать кликабельным текст, который отображается
рядом с флажком. Этот текст заключен внутри тега label. Элемент label связывается с элементом input с помощью атрибута for, в
котором указывается значение атрибута id для элемента input:
<div>
  <input type="radio" id="python" name="language" checked>
  <label for="python">Python</label>
</div>
<div>
  <input type="radio" id="java" name="language">
  <label for="java">Java</label>
</div>

Тогда .click() работает и на lable.

Метод get_attribute()--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Мы можем применить данный метод к найденному элементу для уточнения значения, либо наличия указанного атрибута.
people_checked = people_radio.get_attribute("checked")  - проверяем, выбрано ли значение по-умолчанию, по наличию аттрибута checked.
print("value of people radio: ", people_checked)
assert people_checked is not None, "People radio is not selected by default" - если аттрибут не найден, возвращается None

Если аттрибут найден, то возвращается 'true' от js (с маленькой буквы), так что, можно организовать проверку так:
assert people_checked == "true", "People radio is not selected by default"

Работа со списками-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
На веб-страницах мы также встречаем раскрывающиеся (выпадающие) списки. У таких списков есть несколько важных особенностей:
1. У каждого элемента списка обычно есть уникальное значение атрибута value
2. В списках может быть разрешено выбирать как только один, так и несколько вариантов, в зависимости от типа списка
3. Визуально списки могут различаться тем, что в одном случае все варианты скрыты в выпадающем меню, а в другом все варианты или их часть видны

В html такие списки выглядят так:
<label for="dropdown">Выберите язык программирования:</label>
<select id="dropdown" class="custom-select">
 <option selected>--</option>
 <option value="1">Python</option>
 <option value="2">Java</option>
 <option value="3">JavaScript</option>
</select>

Варианты ответа задаются тегом option, значение value может отсутствовать. Можно отмечать варианты с помощью обычного
метода click(). Для этого сначала нужно применить метод click() для элемента с тегом select, чтобы список раскрылся,
а затем кликнуть на нужный вариант ответа.

browser.find_element(By.TAG_NAME, "select").click()
browser.find_element(By.CSS_SELECTOR, "option:nth-child(2)").click()

Также можно использовать специальный класс Select из библиотеки WebDriver:
from selenium.webdriver.support.ui import Select
select = Select(browser.find_element(By.TAG_NAME, "select"))
select.select_by_value("1") # ищем элемент с текстом "Python"

Для работы с полученным списком есть и другие методы - select.select_by_visible_text("text") и select.select_by_index(index).
Первый будет искать по содержанию варианта ответа, второй - по индексу в списке (нулевой за пустым значением по-умолчанию).

Метод execute_script---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
.execute_script позволяет в автотесте выполнять полноценный скрипт на js
Это может быть полезно, когда мы имеем дело с какими-то нестандартными вещами на страницах, поскольку на данный момент очень много инструментов доступно разработчикам,
и иногда для простого наатия кнопки требуется писать целый скрипт.

Проверить работу скрипта можно в консоли браузера, прежде, чем вставлять в тест.

Вызов алерта в браузере:
from selenium import webdriver
browser = webdriver.Chrome()
browser.execute_script("alert('Robots at work');")

Исполняемый js скрипт нужно брать в кавычки.
Через ; можно указать несколько команд.

Тривиальный пример необходимости этого метода - элемент перекрыт футером или другой частью сайта (куки запрос?), и нужно проскроллить ниже, чтоб нажать.
Но автоматически скроллиться не будет, и попытается нажать на перекрытый элемент, что бросит подробное исключение, в какой точке и какой элемент мешает.
В таком случае, можно использовать команду на js для скролла до тех пор, пока элемент не будет виден:

button = browser.find_element_by_tag_name("button")
browser.execute_script("return arguments[0].scrollIntoView(true);", button)
button.click()

В коде для WebDriver нужно использовать return, хотя в самом js, в данном случае, не нужно. Также мы используем return, когда нам нужно получить какие-то данные после исполнения скрипта.

Также можно проскроллить всю страницу целиком на строго заданное количество пикселей. Эта команда проскроллит страницу на 100 пикселей вниз:
browser.execute_script("window.scrollBy(0, 100);")

Загрузка файлов--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Загрузку файлов на сайт можно реализовать через .send_keys(), но передать не текст, а путь к файлу в качестве аргумента.
Для написания пути, универсального для ос, можно использовать модуль oc:
import os 

current_dir = os.path.abspath(os.path.dirname(__file__))    # получаем путь к директории текущего исполняемого файла вместо пути к самому файлу
file_path = os.path.join(current_dir, 'file.txt')           # добавляем к этому пути имя файла 
element.send_keys(file_path)

Работа с окнами--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Простейший пример окна - всплывающий alert (просто сообщение с кнопкой ок). Это модальное окно, то есть, пока оно открыто, остальной интерфейс заблокирован.

Для его закрытия нужно переключиться на окно алерта и принять его:
alert = browser.switch_to.alert
alert.accept()

.text возвращает содержимое сообщения:
alert_text = alert.text

Другой пример модального окна - confirm. В данном случае можно не только принять, но и отклонить confirm. Переключаемся мы на него такой же командой, как и на алерт:
confirm = browser.switch_to.alert
confirm.accept()
confirm.dismiss()

Третий вид модального окна - prompt. Там добавляется поле для ввода, заполняется через .send_keys():
prompt = browser.switch_to.alert
prompt.send_keys('Answer')
prompt.accept()

Переход на новую вкладку браузера--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
WebDriver может работать только с одной вкладкой сразу, поэтому на открытые новые вкладки надо переключаться явно:
browser.switch_to.window(window_name)

Чтобы узнать имя новой вкладки, нужно использовать метод window_handles, который возвращает массив имён всех вкладок. Зная, что в браузере теперь открыто две вкладки, выбираем вторую вкладку:
new_window = browser.window_handles[1]

Также мы можем запомнить имя текущей вкладки, чтобы иметь возможность потом к ней вернуться:
first_window = browser.window_handles[0]

Настройка ожиданий-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
В современных сайтах используется подход Single-Page Application (или подход одностраничных приложений). Содержимое страницы при этом динамически обновляется с помощью JavaScript,
который незаметно обменивается с сервером информацией, например, посредством REST API.

В целом все довольны. Разве что создателям автотестов на интерфейсы приходится туго. Неожиданно появляющиеся или пропадающие элементы на странице, непредсказуемое время полной отрисовки страницы,
изменяющийся текст в кнопках или в сообщениях веб-сайта — эти особенности работы SPA-приложений приходится учитывать в автотестах, и, стоит признать, это является одним из самых сложных и головоломных
аспектов разработки автотестов на Selenium (да и в других фреймворках для написания end-to-end тестов тоже).

Если кнопка появляется с анимацией в секунду, то за эту секунду тест успеет бросить исключение NoSuchElement (был пример в задании 2.4).

Можно добавить таймер. Но что если элемент с сообщением тоже будет появляться с задержкой? Добавить еще один time.sleep() перед поиском сообщения? А если изменится время задержки при появлении кнопки? Увеличим 
длительность паузы? А еще на разных машинах с разной скоростью интернета кнопка может появляться через разные промежутки времени. Можно перед каждым действием добавить задержку, но тогда значительную часть времени
прогона тестов будут занимать бесполезные ожидания, при этом с увеличением количества тестов эта проблема будет только расти.

В противовес негибкому time.sleep() есть решение - selenium implicit waits (неявное ожидание).
Механизм таков, что, подключив этот метод и задав в нем верхнее значение ожидания (например, 5 секунд), мы заставляем драйвер при ненахождении элемента ожидать его, но
каждые 0.5 секунд он будет проверять доступность. Таким образом, если задержка появляения элемента была низкой, то код будет исполняться практически мгновенно.
Такой паттерн ожидания будет применен ко всем будущим командам.

from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
# говорим WebDriver искать каждый элемент в течение 5 секунд
browser.implicitly_wait(5)

browser.get("http://suninjuly.github.io/wait1.html")

WebDriver может бросить три вида исключения при попытке взаимодействия с элементом:
NoSuchElementException - если за все 5 секунд ожидания так и не было найдено элемента в DOM (Document Object Model).
StaleElementReferenceException - если элемент был найден, но к моменту клика уже пропал (stale - устарел), такое может произойти при деактивации или скрытии кнопки скриптом.
ElementNotVisibleException - если элемент был найден, но невидим (имеет нулевой размер), и пользователь не смог бы с ним взаимодействовать.

Однако, таким образом мы решили только проблему ожидания элементов, в то время как у элементов могут быть разные свойства, которые важны для тестов, но не проверяются через find_element.
Например, кнопка неактивна, содержит текст, который меняется после нажатия, перекрыта другим элементом или невидима. В таком случае нажатие будет проэмулировано, но резульата не будет.

Для надежности теста надо дождаться не только появления кнопки, но и становления ее кликабельной.
Реализуется это через явные ожидания (explicit waits), которые позволяют задать специальное ожидание для конкретного элемента.
Задание явных ожиданий реализуется с помощью инструментов WebDriverWait и expected_conditions.

from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium import webdriver

browser = webdriver.Chrome()

browser.get("http://suninjuly.github.io/wait2.html")

# говорим Selenium проверять в течение 5 секунд, пока кнопка не станет кликабельной (в метод element_to_be... передается кортеж)
button = WebDriverWait(browser, 5).until(
        EC.element_to_be_clickable((By.ID, "verify"))
    )
button.click()
message = browser.find_element(By.ID, "verify_message")

assert "successful" in message.text

element_to_be_clickable возвращает элемент, либо False.
Правило ожидания передается в метод .until(), в модуле EC есть множество правил.
Также есть вариант метода .until_not() для негативации условия (например, чтобы проверить, что кнопка после нажатия стала неактивной).

Тестирование web-приложений--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Сравнение ручного и автоматизированного тестирования:
Шаги для ручного теста могут быть весьма абстрактными (например, зарегестрировать пользователя, без указания способа), поэтому возможно найти новые проблемы, в то время как в автотестах строгий порядок шагов
и их детализация.
Из-за абстрактности описания шагов ручные тесты иногда могут приводить к ложноположительным результатам, когда ожидаемый результат достигнут, но сценарий выполнен не так, как задумывалось, и был пропущен баг.
В то же время, автотесты всегда проходят по одному сценарию.
В ручных тестах требуется много времени для проверки, что ведет к усталости тестировщика и к ошибкам, а автотесты можно запускать хоть на каждый коммит.

Однако, и у автоматизированных тестов есть минусы:
Возможная нестабильность теста, которая связана не с его качеством, а с внешними проблемами (нестабильное сетевое соединение, проблемы с серверами, обновление кода продукта в момент запуска тестов).
Требуется достаточно много времени на разработку и поддержку набора автотестов.

Но в среднем выгоднее делать автоматическое тестирование, так как это быстрее, и баги находятся на ранних этапах разработки, не нужно откладывать релиз ради их решения, и новые фичи выходят быстрее, что выгодно.

Юнит тесты и интеграционные тесты:
Юнит-тесты проверяют очень маленький кусок кода, обычно конкретную функцию, и чаще всего их пишут разработчики, которые хорошо понимают возможные крайние случаи для своего стека технологий.
Интеграционные тесты проверяют взаимодействие сразу нескольких систем. Они могут создаваться и поддерживаться как разработчиками и тестировщиками, так и аналитиками (если для них разработан удобный фреймворк
для написания тестов).

Юнит-тесты всегда автоматизированы, так как проверяют непосредственно работу кода. Интеграционные тесты могут быть ручными и автоматизированными.
Иногда выделяют отдельную категорию end-to-end (е2е) тестов, которые проверяют полный стек технологий приложения и пользовательский сценарий взаимодействия с приложением как с черным ящиком.
UI-тесты, которые разрабатываются с помощью Selenium, стоит отнести к разряду end-to-end тестов, так как они проверяют совместную работу всех систем web-продукта: работу frontend и backend, работу базы данных,
дополнительные сервисы, такие как аналитика, платежные системы и так далее.

Пирамида тестов:
Это примерная концепция, которая показывает, сколько тестов какого вида должно быть, и насколько они комплексны.
Основание пирамиды - Unix тесты, которые пмаленькие и проверяют отдельные фичи. Они простые и их много.
Второй слой - интеграционные (сервисные, куча названий) тесты. Их должно быть меньше, они работают с рядом фич одновременно, поэтому сложнее и дольше работают/пишутся.
Третий слой (иногда вершина) - e2e (end to end, также UI тесты) тесты. Из конца в конец, то есть, это самые большие тесты, проверяющие работу от начала до конца. Их должно быть совсем мало.
Если располагать ручные тесты в пирамиде, то они будут выше e2e, поскольку их должно быть еще меньше, и они еще медленнее.

Структура любого теста:
Входные данные.
Тестовый сценарий, то есть набор шагов, которые надо выполнить для получения результата.
Проверка ожидаемого результата.

Проверка ожидаемого результата:
В python есть встроенная инструкция assert, которая проверяет истинность утверждений. Если он возвращает ложь, бросается исключение с указанием строки.
Когда тестов становится много, сложно вспомнить, что именно проверяется, поэтому можно написать дополнительное сообщение при написании assert через запятую после логического выражения:

>>> assert abs(-42) == -42, "Should be absolute value of a number"
Traceback (most recent call last):

  File "<stdin>", line 1, in <module>

AssertionError: Should be absolute value of a number

Сообщения об ошибках:
Хорошие сообщения в assert могут сохранить часы времениЮ особенно, когда количество тестов уже перевалило за сотню.
Если проверяется наличие элемента, то обязательно пишется, что это за элемент по смыслу на странице.
assert self.is_element_present('create_class_button', timeout=30), "No create class button"
Если элемент встречается на нескольких страницах приложения, не лишним будет указать, где именно произошла ошибка:
assert self.is_element_present('new_announcement_button', timeout=30), "No new announcement button on profile page"
Если проверяется какой-то текст (сообщение, url), то лучше указать два значения - ожидаемое и фактическое.

Способы сделать составное сообщение:
1. Конкатенация строк (не самый читабельный вариант):
actual_result = "abrakadabra"
print("Wrong text, got " + actual_result + ", something wrong")
2. Использование .format():
"Let's count together: {}, then goes {}, and then {}".format("one", "two", "three")
Let's count together: one, then goes two, and then three - вывод.
3. Использование f-string (примерно то же самое, но новее и позволяет четко указывать в фигурных скобках, что там за переменная, либо код (2+3), вместо того, чтоб считать, плюс простая инициализация через f''):
str1 = "one"
str2 = "two"
str3 = "three"
print(f"Let's count together: {str1}, then goes {str2}, and then {str3}")

Любой текст и контент на странице лучше записывать в отдельную переменную, чтоб он не изменился, и мы получили актуальное сообщение об ошибке:
catalog_text = self.catalog_link.text # считываем текст и записываем его в переменную
assert catalog_text == "Каталог", \
    f"Wrong language, got {catalog_text} instead of 'Каталог'"

